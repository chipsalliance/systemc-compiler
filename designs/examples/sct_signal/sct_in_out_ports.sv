//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.11
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: simple_test ()
//
module simple_test // "test_top.dut"
(
    input logic clk,
    input logic nrst
);

// Variables generated for SystemC signals
logic [15:0] run;
logic [15:0] resp;
logic [15:0] fifo_buffer[4];
logic fifo_put_req;
logic fifo_put_req_d;
logic fifo_get_req;
logic fifo_get_req_d;
logic [15:0] fifo_data_in;
logic [15:0] fifo_data_out;
logic fifo_ready_push;
logic fifo_out_valid;
logic [1:0] fifo_pop_indx;
logic [1:0] fifo_push_indx;
logic [2:0] fifo_element_num;
logic [2:0] fifo_element_num_d;
logic fifo_not_empty_d;
logic fifo_clk;
logic fifo_nrst;

// Local parameters generated for C++ constants
localparam logic fifo_SYNC_VALID = 0;
localparam logic fifo_SYNC_READY = 0;
localparam logic fifo_INIT_BUFFER = 0;
localparam logic fifo_cthread_put = 1;
localparam logic fifo_cthread_get = 1;

// Assignments generated for C++ channel arrays
assign fifo_clk = clk;
assign fifo_nrst = nrst;

//------------------------------------------------------------------------------
// Method process: fifo_asyncProc (sct_fifo.h:267:5) 

always_comb 
begin : fifo_asyncProc     // sct_fifo.h:267:5
    logic outValid;
    logic readyPush;
    logic [1:0] popIndx;
    logic notEmpty;
    logic notOne;
    logic notFullOne;
    logic notFull;
    logic push;
    logic pop;
    popIndx = 0;
    notEmpty = fifo_element_num_d != 0;
    notOne = fifo_element_num_d != 1;
    notFullOne = fifo_element_num_d != 4 - 1;
    notFull = fifo_element_num_d != 4;
    push = fifo_put_req != fifo_put_req_d;
    pop = fifo_get_req != fifo_get_req_d;
    if (fifo_cthread_get && pop)
    begin
        outValid = notEmpty && notOne;
        popIndx = (fifo_pop_indx == 4 - 1) ? 0 : fifo_pop_indx + 1;
    end else begin
        outValid = notEmpty;
        popIndx = fifo_pop_indx;
    end
    fifo_not_empty_d = notEmpty;
    if (fifo_cthread_put && push)
    begin
        readyPush = notFull && notFullOne;
    end else begin
        readyPush = notFull;
    end
    fifo_out_valid = push || outValid;
    if (outValid)
    begin
        fifo_data_out = fifo_buffer[popIndx];
    end else begin
        fifo_data_out = fifo_data_in;
    end
    fifo_ready_push = pop || readyPush;
    fifo_element_num = fifo_element_num_d;
    if (pop && !push)
    begin
        fifo_element_num = fifo_element_num_d - 1;
    end else begin
        if (!pop && push)
        begin
            fifo_element_num = fifo_element_num_d + 1;
        end
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fifo_syncProc (sct_fifo.h:320:5) 

// Thread-local variables
logic [1:0] fifo_pop_indx_next;
logic [1:0] fifo_push_indx_next;
logic fifo_put_req_d_next;
logic fifo_get_req_d_next;
logic [2:0] fifo_element_num_d_next;
logic [15:0] fifo_buffer_next[4];

// Next-state combinational logic
always_comb begin : fifo_syncProc_comb     // sct_fifo.h:320:5
    fifo_syncProc_func;
end
function void fifo_syncProc_func;
    logic push;
    logic pop;
    logic A;
    fifo_buffer_next = fifo_buffer;
    fifo_element_num_d_next = fifo_element_num_d;
    fifo_get_req_d_next = fifo_get_req_d;
    fifo_pop_indx_next = fifo_pop_indx;
    fifo_push_indx_next = fifo_push_indx;
    fifo_put_req_d_next = fifo_put_req_d;
    push = fifo_put_req != fifo_put_req_d;
    pop = fifo_get_req != fifo_get_req_d;
    if (pop && fifo_not_empty_d)
    begin
        fifo_pop_indx_next = (fifo_pop_indx == 4 - 1) ? 0 : fifo_pop_indx + 1;
    end
    A = !fifo_SYNC_VALID && !fifo_not_empty_d && pop;
    if (push && !A)
    begin
        fifo_buffer_next[fifo_push_indx] = fifo_data_in;
        fifo_push_indx_next = (fifo_push_indx == 4 - 1) ? 0 : fifo_push_indx + 1;
    end
    fifo_put_req_d_next = fifo_put_req;
    fifo_get_req_d_next = fifo_get_req;
    fifo_element_num_d_next = fifo_element_num;
endfunction

// Synchronous register update
always_ff @(posedge fifo_clk or negedge fifo_nrst) 
begin : fifo_syncProc_ff
    if ( ~fifo_nrst ) begin
        fifo_pop_indx <= 0;
        fifo_push_indx <= 0;
        fifo_put_req_d <= 0;
        fifo_get_req_d <= 0;
        fifo_element_num_d <= 0;
        fifo_buffer[0] <= 0;
    end
    else begin
        fifo_pop_indx <= fifo_pop_indx_next;
        fifo_push_indx <= fifo_push_indx_next;
        fifo_put_req_d <= fifo_put_req_d_next;
        fifo_get_req_d <= fifo_get_req_d_next;
        fifo_element_num_d <= fifo_element_num_d_next;
        fifo_buffer <= fifo_buffer_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: init_thread (signal_port_test.h:87:5) 

// Thread-local variables
logic [15:0] run_next;
logic fifo_get_req_next;
logic fifo_put_req_next;
logic [15:0] fifo_data_in_next;
logic [15:0] data;
logic [15:0] data_next;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [2:0] init_thread_PROC_STATE;
logic [2:0] init_thread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : init_thread_comb     // signal_port_test.h:87:5
    init_thread_func;
end
function void init_thread_func;
    logic [15:0] data_1;
    logic TMP_0;
    logic [15:0] TMP_1;
    logic TMP_2;
    data_next = data;
    fifo_data_in_next = fifo_data_in;
    fifo_get_req_next = fifo_get_req;
    fifo_put_req_next = fifo_put_req;
    i_next = i;
    run_next = run;
    init_thread_PROC_STATE_next = init_thread_PROC_STATE;
    
    case (init_thread_PROC_STATE)
        0: begin
            i_next = 1;
            run_next = i_next;
            data_next = i_next;
            // Call put() begin
            fifo_data_in_next = data_next;
            if (fifo_ready_push)
            begin
                fifo_put_req_next = !fifo_put_req;
                TMP_0 = 1;
            end else begin
                TMP_0 = 0;
            end
            // Call put() end
            init_thread_PROC_STATE_next = 1; return;    // signal_port_test.h:98:13;
        end
        1: begin
            data_1 = resp;
            // Call get() begin
            if (fifo_out_valid)
            begin
                fifo_get_req_next = !fifo_get_req;
            end
            TMP_1 = fifo_data_out;
            // Call get() end
            init_thread_PROC_STATE_next = 2; return;    // signal_port_test.h:105:13;
        end
        2: begin
            i_next++;
            if (i_next < 4)
            begin
                run_next = i_next;
                data_next = i_next;
                // Call put() begin
                fifo_data_in_next = data_next;
                if (fifo_ready_push)
                begin
                    fifo_put_req_next = !fifo_put_req;
                    TMP_2 = 1;
                end else begin
                    TMP_2 = 0;
                end
                // Call put() end
                init_thread_PROC_STATE_next = 1; return;    // signal_port_test.h:98:13;
            end
            init_thread_PROC_STATE_next = 3; return;    // signal_port_test.h:109:9;
        end
        3: begin
            init_thread_PROC_STATE_next = 4; return;    // signal_port_test.h:112:13;
        end
        4: begin
            init_thread_PROC_STATE_next = 4; return;    // signal_port_test.h:112:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge fifo_clk or negedge nrst) 
begin : init_thread_ff
    if ( ~nrst ) begin
        logic [15:0] data_1;
        data_1 = 0;
        run <= 0;
        // Call reset() begin
        // Call reset_get() begin
        fifo_get_req <= 0;
        // Call reset_get() end
        // Call reset_put() begin
        fifo_put_req <= 0;
        fifo_data_in <= 0;
        // Call reset_put() end
        // Call reset() end
        init_thread_PROC_STATE <= 0;    // signal_port_test.h:92:9;
    end
    else begin
        run <= run_next;
        fifo_get_req <= fifo_get_req_next;
        fifo_put_req <= fifo_put_req_next;
        fifo_data_in <= fifo_data_in_next;
        data <= data_next;
        i <= i_next;
        init_thread_PROC_STATE <= init_thread_PROC_STATE_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

A a
(
  .clk(clk),
  .nrst(nrst),
  .run_port(run),
  .resp_port(resp)
);

endmodule



//==============================================================================
//
// Module: A (signal_port_test.h:68:5)
//
module A // "test_top.dut.a"
(
    input logic clk,
    input logic nrst,
    input logic [15:0] run_port,
    output logic [15:0] resp_port
);

// Variables generated for SystemC signals
logic [15:0] s;

//------------------------------------------------------------------------------
// Method process: methProc (signal_port_test.h:36:5) 

always_comb 
begin : methProc     // signal_port_test.h:36:5
    resp_port = run_port + s;
    resp_port = run_port;
    resp_port = run_port;
    resp_port = run_port;
end

//------------------------------------------------------------------------------
// Clocked THREAD: thrdProc (signal_port_test.h:44:5) 

// Thread-local variables
logic [15:0] s_next;

// Next-state combinational logic
always_comb begin : thrdProc_comb     // signal_port_test.h:44:5
    thrdProc_func;
end
function void thrdProc_func;
    s_next = s;
    s_next = run_port + resp_port;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : thrdProc_ff
    if ( ~nrst ) begin
        s <= 0;
    end
    else begin
        s <= s_next;
    end
end

endmodule



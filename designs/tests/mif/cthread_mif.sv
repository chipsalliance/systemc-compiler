//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Dut ()
//
module Dut // "dut"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic a2_rst;
logic [3:0] a2_s;
logic [3:0] a2_ss;
logic a2_clk;

// Assignments generated for C++ channel arrays
assign a2_clk = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: a2_thread1 (test_cthread_mif.cpp:35:5) 

// Thread-local variables
logic [3:0] a2_s_next;
logic [3:0] a2_v;

// Next-state combinational logic
always_comb begin : a2_thread1_comb     // test_cthread_mif.cpp:35:5
    a2_thread1_func;
end
function void a2_thread1_func;
    logic [63:0] a;
    a2_s_next = a2_s;
    a2_v = 3;
    a2_s_next = 4;
    a = a2_v + a2_s;
endfunction

// Synchronous register update
always_ff @(posedge a2_clk or posedge a2_rst) 
begin : a2_thread1_ff
    if ( a2_rst ) begin
        logic [3:0] a2_v;
        a2_s <= 1;
        a2_v = 2;
    end
    else begin
        a2_s <= a2_s_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: a2_thread2 (test_cthread_mif.cpp:49:5) 

// Next-state combinational logic
always_comb begin : a2_thread2_comb     // test_cthread_mif.cpp:49:5
    a2_thread2_func;
end
function void a2_thread2_func;
    logic [3:0] a;
    a = a2_ss;
endfunction

// Synchronous register update
always_ff @(posedge a2_clk or posedge a2_rst) 
begin : a2_thread2_ff
    if ( a2_rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_thread (test_cthread_mif.cpp:76:5) 

// Thread-local variables
logic [3:0] a2_ss_next;
logic [3:0] a2_vv;

// Next-state combinational logic
always_comb begin : top_thread_comb     // test_cthread_mif.cpp:76:5
    top_thread_func;
end
function void top_thread_func;
    logic [63:0] b;
    a2_ss_next = a2_ss;
    a2_ss_next = 3;
    a2_vv = 4;
    b = a2_vv + a2_ss;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_thread_ff
    if ( rst ) begin
        logic [3:0] a2_vv;
        a2_ss <= 1;
        a2_vv = 2;
    end
    else begin
        a2_ss <= a2_ss_next;
    end
end

endmodule



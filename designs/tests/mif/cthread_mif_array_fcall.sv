//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] t;
logic [3:0] minst_s[2];

//------------------------------------------------------------------------------
// Method process: minst_meth (test_cthread_mif_array_fcall.cpp:29:5) 

always_comb 
begin : minst_meth     // test_cthread_mif_array_fcall.cpp:29:5
    logic [3:0] a;
    a = minst_s[0];
end

//------------------------------------------------------------------------------
// Method process: minst_meth0 (test_cthread_mif_array_fcall.cpp:29:5) 

always_comb 
begin : minst_meth0     // test_cthread_mif_array_fcall.cpp:29:5
    logic [3:0] a;
    a = minst_s[1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: top_fcall1 (test_cthread_mif_array_fcall.cpp:70:5) 

// Thread-local variables
logic [3:0] minst_s_next[2];
logic [3:0] minst_v[2];
logic [3:0] minst_v_next[2];

// Next-state combinational logic
always_comb begin : top_fcall1_comb     // test_cthread_mif_array_fcall.cpp:70:5
    top_fcall1_func;
end
function void top_fcall1_func;
    integer i_1;
    logic [3:0] val;
    logic [3:0] l_1;
    minst_s_next = minst_s;
    minst_v_next = minst_v;
    i_1 = t;
    val = 1;
    // Call write() begin
    l_1 = val;
    minst_s_next[i_1] = l_1 + minst_v_next[i_1];
    // Call write() end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : top_fcall1_ff
    if ( rst ) begin
        integer l;
        for (integer i = 0; i < 2; i++)
        begin
            // Call reset() begin
            l = 0;
            minst_v[i] <= l;
            minst_s[i] <= 0;
            // Call reset() end
        end
    end
    else begin
        minst_s <= minst_s_next;
        minst_v <= minst_v_next;
    end
end

endmodule



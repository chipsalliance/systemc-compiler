//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic minst_nrst;
logic minst_s;
logic ninst_nrst;
logic ninst_s;
logic minst_clk;
logic ninst_clk;

// Assignments generated for C++ channel arrays
assign minst_clk = clk;
assign ninst_clk = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: minst_localRecThread (test_record_cthread.cpp:38:5) 

// Thread-local variables
logic [3:0] t_b;
logic [3:0] t_b_next;
logic localRecThread_PROC_STATE;
logic localRecThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : minst_localRecThread_comb     // test_record_cthread.cpp:38:5
    minst_localRecThread_func;
end
function void minst_localRecThread_func;
    logic tt_a;
    logic [3:0] tt_b;
    integer i;
    t_b_next = t_b;
    localRecThread_PROC_STATE_next = localRecThread_PROC_STATE;
    
    case (localRecThread_PROC_STATE)
        0: begin
            tt_a = minst_s;
            tt_b = tt_a ? t_b_next : 4'd0;
            i = t_b_next + tt_b;
            localRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:49:13;
        end
        1: begin
            t_b_next = t_b_next + 1;
            tt_a = minst_s;
            tt_b = tt_a ? t_b_next : 4'd0;
            i = t_b_next + tt_b;
            localRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:49:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_localRecThread_ff
    if ( ~minst_nrst ) begin
        logic t_a;
        logic tt_a;
        logic [3:0] tt_b;
        t_b <= 0;
        tt_b = 0;
        t_a = 0;
        t_b <= 1;
        localRecThread_PROC_STATE <= 0;    // test_record_cthread.cpp:43:9;
    end
    else begin
        t_b <= t_b_next;
        localRecThread_PROC_STATE <= localRecThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_localRecArrThread (test_record_cthread.cpp:56:5) 

// Thread-local variables
logic [3:0] v_b[2];
logic [3:0] v_b_next[2];

// Next-state combinational logic
always_comb begin : minst_localRecArrThread_comb     // test_record_cthread.cpp:56:5
    minst_localRecArrThread_func;
end
function void minst_localRecArrThread_func;
    logic vv_a[4];
    logic [3:0] vv_b[4];
    integer sum;
    v_b_next = v_b;
    vv_a[1] = minst_s;
    vv_b[2] = vv_a[1] ? v_b_next[0] : v_b_next[1];
    sum = 0;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        vv_b[i_1] = (i_1 < 2) ? v_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, vv_b[i_1]});
    end
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_localRecArrThread_ff
    if ( ~minst_nrst ) begin
        logic v_a[2];
        for (integer i = 0; i < 2; ++i)
        begin
            v_a[i] = 0;
            v_b[i] <= i + 1;
        end
    end
    else begin
        v_b <= v_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecThread (test_record_cthread.cpp:83:5) 

// Thread-local variables
logic [3:0] minst_r_b;
logic [3:0] minst_r_b_next;
logic minst_r_a;
logic minst_rr_a;
logic [3:0] minst_rr_b;
logic memRecThread_PROC_STATE;
logic memRecThread_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : minst_memRecThread_comb     // test_record_cthread.cpp:83:5
    minst_memRecThread_func;
end
function void minst_memRecThread_func;
    integer i;
    minst_r_b_next = minst_r_b;
    memRecThread_PROC_STATE_next = memRecThread_PROC_STATE;
    
    case (memRecThread_PROC_STATE)
        0: begin
            minst_rr_a = minst_s;
            minst_rr_b = minst_rr_a ? minst_r_b_next : 4'd0;
            i = minst_r_b_next + minst_rr_b;
            memRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:92:13;
        end
        1: begin
            minst_r_b_next = minst_r_b_next + 1;
            minst_rr_a = minst_s;
            minst_rr_b = minst_rr_a ? minst_r_b_next : 4'd0;
            i = minst_r_b_next + minst_rr_b;
            memRecThread_PROC_STATE_next = 1; return;    // test_record_cthread.cpp:92:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_memRecThread_ff
    if ( ~minst_nrst ) begin
        logic minst_r_a;
        minst_r_a = 0;
        minst_r_b <= 1;
        memRecThread_PROC_STATE <= 0;    // test_record_cthread.cpp:86:9;
    end
    else begin
        minst_r_b <= minst_r_b_next;
        memRecThread_PROC_STATE <= memRecThread_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: minst_memRecArrThread (test_record_cthread.cpp:102:5) 

// Thread-local variables
logic [3:0] minst_w_b[2];
logic [3:0] minst_w_b_next[2];
logic minst_w_a[2];
logic minst_ww_a[4];
logic [3:0] minst_ww_b[4];

// Next-state combinational logic
always_comb begin : minst_memRecArrThread_comb     // test_record_cthread.cpp:102:5
    minst_memRecArrThread_func;
end
function void minst_memRecArrThread_func;
    integer sum;
    minst_w_b_next = minst_w_b;
    minst_ww_a[1] = minst_s;
    minst_ww_b[2] = minst_ww_a[1] ? minst_w_b_next[0] : minst_w_b_next[1];
    sum = 0;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        minst_ww_b[i_1] = (i_1 < 2) ? minst_w_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, minst_ww_b[i_1]});
    end
endfunction

// Synchronous register update
always_ff @(posedge minst_clk or negedge minst_nrst) 
begin : minst_memRecArrThread_ff
    if ( ~minst_nrst ) begin
        logic minst_w_a[2];
        for (integer i = 0; i < 2; ++i)
        begin
            minst_w_a[i] = 0;
            minst_w_b[i] <= i + 1;
        end
    end
    else begin
        minst_w_b <= minst_w_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_localRecThread (test_record_cthread.cpp:38:5) 

// Thread-local variables
logic [3:0] t_b0;
logic [3:0] t_b_next0;
logic localRecThread_PROC_STATE0;
logic localRecThread_PROC_STATE_next0;

// Next-state combinational logic
always_comb begin : ninst_localRecThread_comb     // test_record_cthread.cpp:38:5
    ninst_localRecThread_func;
end
function void ninst_localRecThread_func;
    logic tt_a;
    logic [3:0] tt_b;
    integer i;
    t_b_next0 = t_b0;
    localRecThread_PROC_STATE_next0 = localRecThread_PROC_STATE0;
    
    case (localRecThread_PROC_STATE0)
        0: begin
            tt_a = ninst_s;
            tt_b = tt_a ? t_b_next0 : 4'd0;
            i = t_b_next0 + tt_b;
            localRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:49:13;
        end
        1: begin
            t_b_next0 = t_b_next0 + 1;
            tt_a = ninst_s;
            tt_b = tt_a ? t_b_next0 : 4'd0;
            i = t_b_next0 + tt_b;
            localRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:49:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_localRecThread_ff
    if ( ~ninst_nrst ) begin
        logic t_a;
        logic tt_a;
        logic [3:0] tt_b;
        t_b0 <= 0;
        tt_b = 0;
        t_a = 0;
        t_b0 <= 1;
        localRecThread_PROC_STATE0 <= 0;    // test_record_cthread.cpp:43:9;
    end
    else begin
        t_b0 <= t_b_next0;
        localRecThread_PROC_STATE0 <= localRecThread_PROC_STATE_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_localRecArrThread (test_record_cthread.cpp:56:5) 

// Thread-local variables
logic [3:0] v_b0[2];
logic [3:0] v_b_next0[2];

// Next-state combinational logic
always_comb begin : ninst_localRecArrThread_comb     // test_record_cthread.cpp:56:5
    ninst_localRecArrThread_func;
end
function void ninst_localRecArrThread_func;
    logic vv_a[4];
    logic [3:0] vv_b[4];
    integer sum;
    v_b_next0 = v_b0;
    vv_a[1] = ninst_s;
    vv_b[2] = vv_a[1] ? v_b_next0[0] : v_b_next0[1];
    sum = 0;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        vv_b[i_1] = (i_1 < 2) ? v_b_next0[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, vv_b[i_1]});
    end
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_localRecArrThread_ff
    if ( ~ninst_nrst ) begin
        logic v_a[2];
        for (integer i = 0; i < 2; ++i)
        begin
            v_a[i] = 0;
            v_b0[i] <= i + 1;
        end
    end
    else begin
        v_b0 <= v_b_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_memRecThread (test_record_cthread.cpp:83:5) 

// Thread-local variables
logic [3:0] ninst_r_b;
logic [3:0] ninst_r_b_next;
logic ninst_r_a;
logic ninst_rr_a;
logic [3:0] ninst_rr_b;
logic memRecThread_PROC_STATE0;
logic memRecThread_PROC_STATE_next0;

// Next-state combinational logic
always_comb begin : ninst_memRecThread_comb     // test_record_cthread.cpp:83:5
    ninst_memRecThread_func;
end
function void ninst_memRecThread_func;
    integer i;
    ninst_r_b_next = ninst_r_b;
    memRecThread_PROC_STATE_next0 = memRecThread_PROC_STATE0;
    
    case (memRecThread_PROC_STATE0)
        0: begin
            ninst_rr_a = ninst_s;
            ninst_rr_b = ninst_rr_a ? ninst_r_b_next : 4'd0;
            i = ninst_r_b_next + ninst_rr_b;
            memRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:92:13;
        end
        1: begin
            ninst_r_b_next = ninst_r_b_next + 1;
            ninst_rr_a = ninst_s;
            ninst_rr_b = ninst_rr_a ? ninst_r_b_next : 4'd0;
            i = ninst_r_b_next + ninst_rr_b;
            memRecThread_PROC_STATE_next0 = 1; return;    // test_record_cthread.cpp:92:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_memRecThread_ff
    if ( ~ninst_nrst ) begin
        logic ninst_r_a;
        ninst_r_a = 0;
        ninst_r_b <= 1;
        memRecThread_PROC_STATE0 <= 0;    // test_record_cthread.cpp:86:9;
    end
    else begin
        ninst_r_b <= ninst_r_b_next;
        memRecThread_PROC_STATE0 <= memRecThread_PROC_STATE_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ninst_memRecArrThread (test_record_cthread.cpp:102:5) 

// Thread-local variables
logic [3:0] ninst_w_b[2];
logic [3:0] ninst_w_b_next[2];
logic ninst_w_a[2];
logic ninst_ww_a[4];
logic [3:0] ninst_ww_b[4];

// Next-state combinational logic
always_comb begin : ninst_memRecArrThread_comb     // test_record_cthread.cpp:102:5
    ninst_memRecArrThread_func;
end
function void ninst_memRecArrThread_func;
    integer sum;
    ninst_w_b_next = ninst_w_b;
    ninst_ww_a[1] = ninst_s;
    ninst_ww_b[2] = ninst_ww_a[1] ? ninst_w_b_next[0] : ninst_w_b_next[1];
    sum = 0;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        ninst_ww_b[i_1] = (i_1 < 2) ? ninst_w_b_next[i_1] : 4'(i_1);
        sum = sum + signed'({1'b0, ninst_ww_b[i_1]});
    end
endfunction

// Synchronous register update
always_ff @(posedge ninst_clk or negedge ninst_nrst) 
begin : ninst_memRecArrThread_ff
    if ( ~ninst_nrst ) begin
        logic ninst_w_a[2];
        for (integer i = 0; i < 2; ++i)
        begin
            ninst_w_a[i] = 0;
            ninst_w_b[i] <= i + 1;
        end
    end
    else begin
        ninst_w_b <= ninst_w_b_next;
    end
end

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic [15:0] p_s[2];
logic [31:0] s;
logic p_clk[2];
logic p_rstn[2];

// Local parameters generated for C++ constants
localparam logic [31:0] p_C[2][2] = '{ '{ 11, 22 }, '{ 11, 22 } };

// Assignments generated for C++ channel arrays
assign p_clk[0] = clk;
assign p_clk[1] = clk;
assign p_rstn[0] = rstn;
assign p_rstn[1] = rstn;

//------------------------------------------------------------------------------
// Clocked THREAD: p_threadProc (test_sc_vector_mif2.cpp:36:5) 

// Thread-local variables
logic [31:0] p_req[2][3];
logic [31:0] p_req_next[2][3];
logic [15:0] p_data[2][3];
logic [15:0] p_data_next[2][3];
logic [15:0] p_s_next[2];

// Next-state combinational logic
always_comb begin : p_threadProc_comb     // test_sc_vector_mif2.cpp:36:5
    p_threadProc_func;
end
function void p_threadProc_func;
    p_data_next[0] = p_data[0];
    p_req_next[0] = p_req[0];
    p_s_next[0] = p_s[0];
    for (integer i_1 = 0; i_1 < 3; ++i_1)
    begin
        p_data_next[0][i_1] = |p_req_next[0][i_1] ? i_1 : p_C[0][i_1 % 2];
        p_req_next[0][i_1]++;
    end
    p_s_next[0] = p_data_next[0][p_s[0]];
endfunction

// Synchronous register update
always_ff @(posedge p_clk[0] or negedge p_rstn[0]) 
begin : p_threadProc_ff
    if ( ~p_rstn[0] ) begin
        for (integer i = 0; i < 3; ++i)
        begin
            p_data[0][i] <= 0;
            p_req[0][i] <= 1;
        end
    end
    else begin
        p_req[0] <= p_req_next[0];
        p_data[0] <= p_data_next[0];
        p_s[0] <= p_s_next[0];
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: p_threadProc0 (test_sc_vector_mif2.cpp:36:5) 

// Next-state combinational logic
always_comb begin : p_threadProc0_comb     // test_sc_vector_mif2.cpp:36:5
    p_threadProc0_func;
end
function void p_threadProc0_func;
    p_data_next[1] = p_data[1];
    p_req_next[1] = p_req[1];
    p_s_next[1] = p_s[1];
    for (integer i_1 = 0; i_1 < 3; ++i_1)
    begin
        p_data_next[1][i_1] = |p_req_next[1][i_1] ? i_1 : p_C[1][i_1 % 2];
        p_req_next[1][i_1]++;
    end
    p_s_next[1] = p_data_next[1][p_s[1]];
endfunction

// Synchronous register update
always_ff @(posedge p_clk[1] or negedge p_rstn[1]) 
begin : p_threadProc0_ff
    if ( ~p_rstn[1] ) begin
        for (integer i = 0; i < 3; ++i)
        begin
            p_data[1][i] <= 0;
            p_req[1][i] <= 1;
        end
    end
    else begin
        p_req[1] <= p_req_next[1];
        p_data[1] <= p_data_next[1];
        p_s[1] <= p_s_next[1];
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: mainProc (test_sc_vector_mif2.cpp:81:5) 

// Thread-local variables
logic [15:0] res;
logic [15:0] res_next;
logic mainProc_PROC_STATE;
logic mainProc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : mainProc_comb     // test_sc_vector_mif2.cpp:81:5
    mainProc_func;
end
function void mainProc_func;
    integer unsigned u;
    logic [15:0] TMP_0;
    integer indx;
    logic [15:0] TMP_2;
    res_next = res;
    mainProc_PROC_STATE_next = mainProc_PROC_STATE;
    
    case (mainProc_PROC_STATE)
        0: begin
            u = s;
            indx = u + 1;
            // Call getData() begin
            TMP_0 = p_s[u] + indx;
            // Call getData() end
            res_next = TMP_0;
            mainProc_PROC_STATE_next = 1; return;    // test_sc_vector_mif2.cpp:88:13;
        end
        1: begin
            res_next++;
            u = s;
            indx = u + 1;
            // Call getData() begin
            TMP_2 = p_s[u] + indx;
            // Call getData() end
            res_next = TMP_2;
            mainProc_PROC_STATE_next = 1; return;    // test_sc_vector_mif2.cpp:88:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : mainProc_ff
    if ( ~rstn ) begin
        mainProc_PROC_STATE <= 0;    // test_sc_vector_mif2.cpp:82:9;
    end
    else begin
        res <= res_next;
        mainProc_PROC_STATE <= mainProc_PROC_STATE_next;
    end
end

endmodule



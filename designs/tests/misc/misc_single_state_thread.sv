//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.32
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_mod ()
//
module test_mod // "t"
(
);

// Variables generated for SystemC signals
logic clk;
logic rstn;

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread0 (test_single_state_thread.cpp:73:5) 

// Thread-local variables
logic signed [31:0] x;
logic signed [31:0] x_next;

// Next-state combinational logic
always_comb begin : single_state_thread0_comb     // test_single_state_thread.cpp:73:5
    single_state_thread0_func;
end
function void single_state_thread0_func;
    x_next = x;
    x_next++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread0_ff
    if ( ~rstn ) begin
        x <= 0;
    end
    else begin
        x <= x_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread1 (test_single_state_thread.cpp:82:5) 

// Thread-local variables
logic signed [31:0] x0;
logic signed [31:0] x_next0;

// Next-state combinational logic
always_comb begin : single_state_thread1_comb     // test_single_state_thread.cpp:82:5
    single_state_thread1_func;
end
function void single_state_thread1_func;
    x_next0 = x0;
    x_next0++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread1_ff
    if ( ~rstn ) begin
        x0 <= 0;
    end
    else begin
        x0 <= x_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread2 (test_single_state_thread.cpp:91:5) 

// Thread-local variables
logic signed [31:0] x1;
logic signed [31:0] x_next1;

// Next-state combinational logic
always_comb begin : single_state_thread2_comb     // test_single_state_thread.cpp:91:5
    single_state_thread2_func;
end
function void single_state_thread2_func;
    x_next1 = x1;
    x_next1++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread2_ff
    if ( ~rstn ) begin
        x1 <= 0;
    end
    else begin
        x1 <= x_next1;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread3 (test_single_state_thread.cpp:100:5) 

// Thread-local variables
logic signed [31:0] x2;
logic signed [31:0] x_next2;

// Next-state combinational logic
always_comb begin : single_state_thread3_comb     // test_single_state_thread.cpp:100:5
    single_state_thread3_func;
end
function void single_state_thread3_func;
    x_next2 = x2;
    x_next2++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread3_ff
    if ( ~rstn ) begin
        x2 <= 0;
    end
    else begin
        x2 <= x_next2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: single_state_thread4 (test_single_state_thread.cpp:112:5) 

// Thread-local variables
logic signed [31:0] x3;
logic signed [31:0] x_next3;

// Next-state combinational logic
always_comb begin : single_state_thread4_comb     // test_single_state_thread.cpp:112:5
    single_state_thread4_func;
end
function void single_state_thread4_func;
    x_next3 = x3;
    x_next3++;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : single_state_thread4_ff
    if ( ~rstn ) begin
        x3 <= 0;
    end
    else begin
        x3 <= x_next3;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread0 (test_single_state_thread.cpp:121:5) 

// Thread-local variables
logic signed [31:0] x4;
logic signed [31:0] x_next4;
logic multistate_thread0_PROC_STATE;
logic multistate_thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread0_comb     // test_single_state_thread.cpp:121:5
    multistate_thread0_func;
end
function void multistate_thread0_func;
    x_next4 = x4;
    multistate_thread0_PROC_STATE_next = multistate_thread0_PROC_STATE;
    
    case (multistate_thread0_PROC_STATE)
        0: begin
            x_next4++;
            x_next4++;
            multistate_thread0_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:127:13;
        end
        1: begin
            x_next4++;
            multistate_thread0_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:127:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread0_ff
    if ( ~rstn ) begin
        x4 <= 0;
        multistate_thread0_PROC_STATE <= 0;    // test_single_state_thread.cpp:123:9;
    end
    else begin
        x4 <= x_next4;
        multistate_thread0_PROC_STATE <= multistate_thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread1 (test_single_state_thread.cpp:131:5) 

// Thread-local variables
logic signed [31:0] x5;
logic signed [31:0] x_next5;
logic multistate_thread1_PROC_STATE;
logic multistate_thread1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread1_comb     // test_single_state_thread.cpp:131:5
    multistate_thread1_func;
end
function void multistate_thread1_func;
    x_next5 = x5;
    multistate_thread1_PROC_STATE_next = multistate_thread1_PROC_STATE;
    
    case (multistate_thread1_PROC_STATE)
        0: begin
            multistate_thread1_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:135:13;
        end
        1: begin
            x_next5++;
            multistate_thread1_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:135:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread1_ff
    if ( ~rstn ) begin
        x5 <= 0;
        multistate_thread1_PROC_STATE <= 0;    // test_single_state_thread.cpp:133:9;
    end
    else begin
        x5 <= x_next5;
        multistate_thread1_PROC_STATE <= multistate_thread1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread2 (test_single_state_thread.cpp:144:5) 

// Thread-local variables
logic signed [31:0] x6;
logic signed [31:0] x_next6;
logic multistate_thread2_PROC_STATE;
logic multistate_thread2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread2_comb     // test_single_state_thread.cpp:144:5
    multistate_thread2_func;
end
function void multistate_thread2_func;
    x_next6 = x6;
    multistate_thread2_PROC_STATE_next = multistate_thread2_PROC_STATE;
    
    case (multistate_thread2_PROC_STATE)
        0: begin
            // Call wait_method() begin
            multistate_thread2_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:141:9;
            // Call wait_method() end
        end
        1: begin
            x_next6++;
            multistate_thread2_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:147:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread2_ff
    if ( ~rstn ) begin
        x6 <= 0;
        multistate_thread2_PROC_STATE <= 0;    // test_single_state_thread.cpp:147:13;
    end
    else begin
        x6 <= x_next6;
        multistate_thread2_PROC_STATE <= multistate_thread2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread3 (test_single_state_thread.cpp:153:5) 

// Thread-local variables
logic signed [31:0] x7;
logic signed [31:0] x_next7;
logic multistate_thread3_PROC_STATE;
logic multistate_thread3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread3_comb     // test_single_state_thread.cpp:153:5
    multistate_thread3_func;
end
function void multistate_thread3_func;
    x_next7 = x7;
    multistate_thread3_PROC_STATE_next = multistate_thread3_PROC_STATE;
    
    case (multistate_thread3_PROC_STATE)
        0: begin
            // Call wait_wrapper() begin
            multistate_thread3_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:32:5;
            // Call wait_wrapper() end
        end
        1: begin
            x_next7++;
            multistate_thread3_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:156:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread3_ff
    if ( ~rstn ) begin
        x7 <= 0;
        multistate_thread3_PROC_STATE <= 0;    // test_single_state_thread.cpp:156:13;
    end
    else begin
        x7 <= x_next7;
        multistate_thread3_PROC_STATE <= multistate_thread3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread4 (test_single_state_thread.cpp:162:5) 

// Thread-local variables
logic signed [31:0] x8;
logic signed [31:0] x_next8;
logic signed [31:0] wptr_y;
logic signed [31:0] wptr_y_next;
logic multistate_thread4_PROC_STATE;
logic multistate_thread4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread4_comb     // test_single_state_thread.cpp:162:5
    multistate_thread4_func;
end
function void multistate_thread4_func;
    wptr_y_next = wptr_y;
    x_next8 = x8;
    multistate_thread4_PROC_STATE_next = multistate_thread4_PROC_STATE;
    
    case (multistate_thread4_PROC_STATE)
        0: begin
            // Call vwait() begin
            wptr_y_next = wptr_y_next + 2;
            multistate_thread4_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:26:9;
            // Call vwait() end
        end
        1: begin
            x_next8++;
            multistate_thread4_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:165:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread4_ff
    if ( ~rstn ) begin
        x8 <= 0;
        multistate_thread4_PROC_STATE <= 0;    // test_single_state_thread.cpp:165:13;
    end
    else begin
        x8 <= x_next8;
        wptr_y <= wptr_y_next;
        multistate_thread4_PROC_STATE <= multistate_thread4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: multistate_thread5 (test_single_state_thread.cpp:177:5) 

// Thread-local variables
logic signed [31:0] x9;
logic signed [31:0] x_next9;
logic signed [31:0] wd_y;
logic signed [31:0] wd_y_next;
logic multistate_thread5_PROC_STATE;
logic multistate_thread5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : multistate_thread5_comb     // test_single_state_thread.cpp:177:5
    multistate_thread5_func;
end
function void multistate_thread5_func;
    wd_y_next = wd_y;
    x_next9 = x9;
    multistate_thread5_PROC_STATE_next = multistate_thread5_PROC_STATE;
    
    case (multistate_thread5_PROC_STATE)
        0: begin
            // Call wbase_invoker() begin
            // Call vwait() begin
            wd_y_next = wd_y_next + 2;
            multistate_thread5_PROC_STATE_next = 1; return;    // test_single_state_thread.cpp:26:9;
            // Call vwait() end
            // Call wbase_invoker() end
        end
        1: begin
            x_next9++;
            multistate_thread5_PROC_STATE_next = 0; return;    // test_single_state_thread.cpp:180:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : multistate_thread5_ff
    if ( ~rstn ) begin
        x9 <= 0;
        multistate_thread5_PROC_STATE <= 0;    // test_single_state_thread.cpp:180:13;
    end
    else begin
        x9 <= x_next9;
        wd_y <= wd_y_next;
        multistate_thread5_PROC_STATE <= multistate_thread5_PROC_STATE_next;
    end
end

endmodule



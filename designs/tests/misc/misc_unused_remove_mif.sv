//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.32
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B ()
//
module B // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic a_nrst[3];
logic a_mw_renbl[3][2];
logic a_mw_rdata_valid[3][2];
logic a_clk[3];

// Local parameters generated for C++ constants
localparam logic [31:0] a_PORTS_NUM = 2;

// Assignments generated for C++ channel arrays
assign a_clk[0] = clk;
assign a_clk[1] = clk;
assign a_clk[2] = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: a_dvalidProc (test_unused_remove_mif.cpp:29:5) 

// Thread-local variables
logic a_mw_rdata_valid_next[3][2];

// Next-state combinational logic
always_comb begin : a_dvalidProc_comb     // test_unused_remove_mif.cpp:29:5
    a_dvalidProc_func;
end
function void a_dvalidProc_func;
    a_mw_rdata_valid_next[0] = a_mw_rdata_valid[0];
    for (integer unsigned p_1 = 0; p_1 < a_PORTS_NUM; ++p_1)
    begin
        a_mw_rdata_valid_next[0][p_1] = a_mw_renbl[0][p_1];
    end
endfunction

// Synchronous register update
always_ff @(posedge a_clk[0] or negedge a_nrst[0]) 
begin : a_dvalidProc_ff
    if ( ~a_nrst[0] ) begin
        for (integer unsigned p = 0; p < a_PORTS_NUM; ++p)
        begin
            a_mw_rdata_valid[0][p] <= 0;
        end
    end
    else begin
        a_mw_rdata_valid[0] <= a_mw_rdata_valid_next[0];
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: a_dvalidProc0 (test_unused_remove_mif.cpp:29:5) 

// Next-state combinational logic
always_comb begin : a_dvalidProc0_comb     // test_unused_remove_mif.cpp:29:5
    a_dvalidProc0_func;
end
function void a_dvalidProc0_func;
    a_mw_rdata_valid_next[1] = a_mw_rdata_valid[1];
    for (integer unsigned p_1 = 0; p_1 < a_PORTS_NUM; ++p_1)
    begin
        a_mw_rdata_valid_next[1][p_1] = a_mw_renbl[1][p_1];
    end
endfunction

// Synchronous register update
always_ff @(posedge a_clk[1] or negedge a_nrst[1]) 
begin : a_dvalidProc0_ff
    if ( ~a_nrst[1] ) begin
        for (integer unsigned p = 0; p < a_PORTS_NUM; ++p)
        begin
            a_mw_rdata_valid[1][p] <= 0;
        end
    end
    else begin
        a_mw_rdata_valid[1] <= a_mw_rdata_valid_next[1];
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: a_dvalidProc1 (test_unused_remove_mif.cpp:29:5) 

// Next-state combinational logic
always_comb begin : a_dvalidProc1_comb     // test_unused_remove_mif.cpp:29:5
    a_dvalidProc1_func;
end
function void a_dvalidProc1_func;
    a_mw_rdata_valid_next[2] = a_mw_rdata_valid[2];
    for (integer unsigned p_1 = 0; p_1 < a_PORTS_NUM; ++p_1)
    begin
        a_mw_rdata_valid_next[2][p_1] = a_mw_renbl[2][p_1];
    end
endfunction

// Synchronous register update
always_ff @(posedge a_clk[2] or negedge a_nrst[2]) 
begin : a_dvalidProc1_ff
    if ( ~a_nrst[2] ) begin
        for (integer unsigned p = 0; p < a_PORTS_NUM; ++p)
        begin
            a_mw_rdata_valid[2][p] <= 0;
        end
    end
    else begin
        a_mw_rdata_valid[2] <= a_mw_rdata_valid_next[2];
    end
end

endmodule



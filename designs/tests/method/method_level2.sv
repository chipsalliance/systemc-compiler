//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.16
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic signed [31:0] s;
logic signed [31:0] t;
logic [7:0] s2;

// Local parameters generated for C++ constants
localparam logic [31:0] CONST_Z = 0;

//------------------------------------------------------------------------------
// Clocked THREAD: local_array (test_level2.cpp:82:5) 

// Next-state combinational logic
always_comb begin : local_array_comb     // test_level2.cpp:82:5
    local_array_func;
end
function void local_array_func;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : local_array_ff
    if ( ~nrst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Method process: empty_for (test_level2.cpp:93:5) 

always_comb 
begin : empty_for     // test_level2.cpp:93:5
    integer k;
    integer l;
    integer m;
    for (integer i = 0; i < 3; i++)
    begin
        k = i;
        for (integer j = 0; j < 2; j++)
        begin
            l = i + j;
        end
    end
    m = 0;
end

//------------------------------------------------------------------------------
// Method process: empty_for2 (test_level2.cpp:105:5) 

always_comb 
begin : empty_for2     // test_level2.cpp:105:5
    integer m;
    m = 0;
end

//------------------------------------------------------------------------------
// Method process: empty_for2_extr (test_level2.cpp:123:5) 

always_comb 
begin : empty_for2_extr     // test_level2.cpp:123:5
    integer m;
    integer i;
    m = 0;
    for (i = 0; i < 3; i++)
    begin
    end
    for (; i < 6; i++)
    begin
    end
    for (integer j = 0; i < 9; i++)
    begin
    end
end

//------------------------------------------------------------------------------
// Method process: empty_for3_extr (test_level2.cpp:132:5) 

always_comb 
begin : empty_for3_extr     // test_level2.cpp:132:5
    integer m;
    integer i;
    m = 0;
    i = 42;
    for (; i > 40; i--)
    begin
    end
    for (i++; i > 38; i--)
    begin
    end
    for (i = i - 1; i > 0; i--)
    begin
    end
end

//------------------------------------------------------------------------------
// Method process: empty_for4_extr (test_level2.cpp:141:5) 

always_comb 
begin : empty_for4_extr     // test_level2.cpp:141:5
    integer m;
    m = 1;
end

//------------------------------------------------------------------------------
// Method process: empty_do (test_level2.cpp:147:5) 

always_comb 
begin : empty_do     // test_level2.cpp:147:5
    integer i;
    i = 0;
end

//------------------------------------------------------------------------------
// Clocked THREAD: for_stmt_wait (test_level2.cpp:154:5) 

// Thread-local variables
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic for_stmt_wait_PROC_STATE;
logic for_stmt_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : for_stmt_wait_comb     // test_level2.cpp:154:5
    for_stmt_wait_func;
end
function void for_stmt_wait_func;
    i_next = i0;
    for_stmt_wait_PROC_STATE_next = for_stmt_wait_PROC_STATE;
    
    case (for_stmt_wait_PROC_STATE)
        0: begin
            i_next = 0;
            for_stmt_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:160:17;
        end
        1: begin
            i_next++;
            if (i_next < 2)
            begin
                for_stmt_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:160:17;
            end
            for_stmt_wait_PROC_STATE_next = 0; return;    // test_level2.cpp:157:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : for_stmt_wait_ff
    if ( ~nrst ) begin
        for_stmt_wait_PROC_STATE <= 0;    // test_level2.cpp:157:13;
    end
    else begin
        i0 <= i_next;
        for_stmt_wait_PROC_STATE <= for_stmt_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: complex_logic (test_level2.cpp:175:5) 

always_comb 
begin : complex_logic     // test_level2.cpp:175:5
    logic b3;
    logic b4;
    b3 = 0;
    b4 = 0;    // Call of f()
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_for_wait (test_level2.cpp:180:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic signed [31:0] k0;
logic signed [31:0] k_next;
logic [1:0] simple_for_wait_PROC_STATE;
logic [1:0] simple_for_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : simple_for_wait_comb     // test_level2.cpp:180:5
    simple_for_wait_func;
end
function void simple_for_wait_func;
    i_next0 = i1;
    k_next = k0;
    simple_for_wait_PROC_STATE_next = simple_for_wait_PROC_STATE;
    
    case (simple_for_wait_PROC_STATE)
        0: begin
            k_next = s;
            i_next0 = 0;
            if (i_next0 < k_next)
            begin
                simple_for_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:187:17;
            end
            simple_for_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:189:13;
        end
        1: begin
            i_next0++;
            if (i_next0 < k_next)
            begin
                simple_for_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:187:17;
            end
            simple_for_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:189:13;
        end
        2: begin
            k_next = s;
            i_next0 = 0;
            if (i_next0 < k_next)
            begin
                simple_for_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:187:17;
            end
            simple_for_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:189:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : simple_for_wait_ff
    if ( ~nrst ) begin
        simple_for_wait_PROC_STATE <= 0;    // test_level2.cpp:181:9;
    end
    else begin
        i1 <= i_next0;
        k0 <= k_next;
        simple_for_wait_PROC_STATE <= simple_for_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: loop_cntr_name (test_level2.cpp:198:5) 

always_comb 
begin : loop_cntr_name     // test_level2.cpp:198:5
    integer i_1;
    logic [3:0] i_2;
    for (integer i = 0; i < 4; ++i)
    begin
        i_1 = i;
    end
    i_2 = 2;
    for (integer i_3 = 0; i_3 < 4; ++i_3)
    begin
        i_1 = i_3;
    end
    i_2 = 3;
end

//------------------------------------------------------------------------------
// Method process: loop_cntr_name2 (test_level2.cpp:210:5) 

always_comb 
begin : loop_cntr_name2     // test_level2.cpp:210:5
    logic [3:0] i;
    integer i_2;
    i = 2;
    for (integer i_1 = 0; i_1 < 4; ++i_1)
    begin
        i_2 = i_1;
    end
    i = 3;
end

//------------------------------------------------------------------------------
// Method process: multi_for (test_level2.cpp:220:5) 

always_comb 
begin : multi_for     // test_level2.cpp:220:5
    s2 = 0;
    for (integer i = 0; i < 2; i++)
    begin
        for (integer k = 0; k < 3; k++)
        begin
            s2 = k + 2;
        end
    end
end

//------------------------------------------------------------------------------
// Method process: do_while3 (test_level2.cpp:231:5) 

always_comb 
begin : do_while3     // test_level2.cpp:231:5
    integer i;
    i = 0;
    do
    begin
        i++;
    end
    while (i < 2);
    i = 4;
end

//------------------------------------------------------------------------------
// Method process: func_with_loop (test_level2.cpp:249:5) 

always_comb 
begin : func_with_loop     // test_level2.cpp:249:5
    integer j;
    j = 3;    // Call of f5()
end

//------------------------------------------------------------------------------
// Method process: switch_for2 (test_level2.cpp:253:5) 

always_comb 
begin : switch_for2     // test_level2.cpp:253:5
    integer k;
    k = 0;
    case (s)
    1 : begin
        for (integer i = 0; i < 3; i++)
        begin
            k = k + 1;
        end
        for (integer j = 0; j < 4; j++)
        begin
            k = k - 1;
        end
    end
    default : begin
    end
    endcase
end

//------------------------------------------------------------------------------
// Method process: switch_if (test_level2.cpp:268:5) 

always_comb 
begin : switch_if     // test_level2.cpp:268:5
    integer i;
    i = 0;
    case (s)
    1 : begin  // Empty case without break
        if (s == 1)
        begin
            i = 1;
        end
        i = 3;
    end
    2 : begin
        if (s == 1)
        begin
            i = 1;
        end
        i = 3;
    end
    endcase
    i = 4;
end

//------------------------------------------------------------------------------
// Method process: switch_if_const (test_level2.cpp:285:5) 

always_comb 
begin : switch_if_const     // test_level2.cpp:285:5
    integer i;
    i = 0;
    case (s)
    1 : begin
    end
    2 : begin
        i = 1;
    end
    endcase
    i = 2;
end

//------------------------------------------------------------------------------
// Clocked THREAD: while_wait (test_level2.cpp:297:5) 

// Thread-local variables
logic [1:0] while_wait_PROC_STATE;
logic [1:0] while_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : while_wait_comb     // test_level2.cpp:297:5
    while_wait_func;
end
function void while_wait_func;
    integer i;
    while_wait_PROC_STATE_next = while_wait_PROC_STATE;
    
    case (while_wait_PROC_STATE)
        0: begin
            if (s == 42)
            begin
                while_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:303:36;
            end
            i = 1;
            while_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:306:13;
        end
        1: begin
            if (s == 42)
            begin
                while_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:303:36;
            end
            i = 1;
            while_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:306:13;
        end
        2: begin
            i = 2;
            while_wait_PROC_STATE_next = 3; return;    // test_level2.cpp:309:13;
        end
        3: begin
            if (s == 42)
            begin
                while_wait_PROC_STATE_next = 1; return;    // test_level2.cpp:303:36;
            end
            i = 1;
            while_wait_PROC_STATE_next = 2; return;    // test_level2.cpp:306:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : while_wait_ff
    if ( ~nrst ) begin
        integer i;
        i = 0;
        while_wait_PROC_STATE <= 0;    // test_level2.cpp:300:9;
    end
    else begin
        while_wait_PROC_STATE <= while_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: two_do_while (test_level2.cpp:313:5) 

always_comb 
begin : two_do_while     // test_level2.cpp:313:5
    integer i;
    i = 0;
    do
    begin
        i--;
    end
    while (s < 1);
    do
    begin
        i++;
    end
    while (s < 2);
end

//------------------------------------------------------------------------------
// Clocked THREAD: break_in_while_for (test_level2.cpp:325:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic [1:0] break_in_while_for_PROC_STATE;
logic [1:0] break_in_while_for_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : break_in_while_for_comb     // test_level2.cpp:325:5
    break_in_while_for_func;
end
function void break_in_while_for_func;
    integer k;
    i_next1 = i2;
    break_in_while_for_PROC_STATE_next = break_in_while_for_PROC_STATE;
    
    case (break_in_while_for_PROC_STATE)
        0: begin
            if (|s || |t)
            begin
                if (|s)
                begin
                    k = 1;
                    i_next1 = 0;
                    break_in_while_for_PROC_STATE_next = 1; return;    // test_level2.cpp:336:25;
                end
                break_in_while_for_PROC_STATE_next = 2; return;    // test_level2.cpp:342:17;
            end
            k = 4;
            break_in_while_for_PROC_STATE_next = 3; return;    // test_level2.cpp:346:13;
        end
        1: begin
            if (|s)
            begin
                // break begin
                if (|t)
                begin
                    k = 3;
                end
                k = 2;
                break_in_while_for_PROC_STATE_next = 2; return;    // test_level2.cpp:342:17;
                // break end
            end
            i_next1++;
            if (i_next1 < 3)
            begin
                break_in_while_for_PROC_STATE_next = 1; return;    // test_level2.cpp:336:25;
            end
            if (|t)
            begin
                k = 3;
            end
            k = 2;
            break_in_while_for_PROC_STATE_next = 2; return;    // test_level2.cpp:342:17;
        end
        2: begin
            k = 3;
            if (|s || |t)
            begin
                if (|s)
                begin
                    k = 1;
                    i_next1 = 0;
                    break_in_while_for_PROC_STATE_next = 1; return;    // test_level2.cpp:336:25;
                end
                break_in_while_for_PROC_STATE_next = 2; return;    // test_level2.cpp:342:17;
            end
            k = 4;
            break_in_while_for_PROC_STATE_next = 3; return;    // test_level2.cpp:346:13;
        end
        3: begin
            if (|s || |t)
            begin
                if (|s)
                begin
                    k = 1;
                    i_next1 = 0;
                    break_in_while_for_PROC_STATE_next = 1; return;    // test_level2.cpp:336:25;
                end
                break_in_while_for_PROC_STATE_next = 2; return;    // test_level2.cpp:342:17;
            end
            k = 4;
            break_in_while_for_PROC_STATE_next = 3; return;    // test_level2.cpp:346:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : break_in_while_for_ff
    if ( ~nrst ) begin
        integer k;
        k = 0;
        break_in_while_for_PROC_STATE <= 0;    // test_level2.cpp:328:9;
    end
    else begin
        i2 <= i_next1;
        break_in_while_for_PROC_STATE <= break_in_while_for_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Method process: empty_loop_method (test_level2.cpp:350:5) 

always_comb 
begin : empty_loop_method     // test_level2.cpp:350:5
    integer j;
    integer k;
    j = 0;
    k = 0;
    while (j < 3)
    begin
        while (k < 4)
        begin
            k++;
        end
        j++;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: switch_if3 (test_level2.cpp:365:5) 

// Next-state combinational logic
always_comb begin : switch_if3_comb     // test_level2.cpp:365:5
    switch_if3_func;
end
function void switch_if3_func;
    integer i;
    case (s)
    1 : begin  // Empty case without break
        i = 2;
    end
    2 : begin
        i = 2;
    end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : switch_if3_ff
    if ( ~nrst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: two_loops (test_level2.cpp:378:5) 

// Thread-local variables
logic [1:0] two_loops_PROC_STATE;
logic [1:0] two_loops_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : two_loops_comb     // test_level2.cpp:378:5
    two_loops_func;
end
function void two_loops_func;
    integer j;
    two_loops_PROC_STATE_next = two_loops_PROC_STATE;
    
    case (two_loops_PROC_STATE)
        0: begin
            for (integer i = 0; i < 3; i++)
            begin
                j = i;
            end
            two_loops_PROC_STATE_next = 1; return;    // test_level2.cpp:387:17;
        end
        1: begin
            if (|s)
            begin
                // break begin
                two_loops_PROC_STATE_next = 2; return;    // test_level2.cpp:390:13;
                // break end
            end
            two_loops_PROC_STATE_next = 1; return;    // test_level2.cpp:387:17;
        end
        2: begin
            for (integer i = 0; i < 3; i++)
            begin
                j = i;
            end
            two_loops_PROC_STATE_next = 1; return;    // test_level2.cpp:387:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : two_loops_ff
    if ( ~nrst ) begin
        integer j;
        j = 0;
        two_loops_PROC_STATE <= 0;    // test_level2.cpp:381:9;
    end
    else begin
        two_loops_PROC_STATE <= two_loops_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: if_and_loop (test_level2.cpp:394:5) 

// Thread-local variables
logic [1:0] if_and_loop_PROC_STATE;
logic [1:0] if_and_loop_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : if_and_loop_comb     // test_level2.cpp:394:5
    if_and_loop_func;
end
function void if_and_loop_func;
    integer j;
    if_and_loop_PROC_STATE_next = if_and_loop_PROC_STATE;
    
    case (if_and_loop_PROC_STATE)
        0: begin
            if (|s)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    j = i;
                end
            end
            if_and_loop_PROC_STATE_next = 1; return;    // test_level2.cpp:405:17;
        end
        1: begin
            if (|s)
            begin
                // break begin
                if_and_loop_PROC_STATE_next = 2; return;    // test_level2.cpp:408:13;
                // break end
            end
            if_and_loop_PROC_STATE_next = 1; return;    // test_level2.cpp:405:17;
        end
        2: begin
            if (|s)
            begin
                for (integer i = 0; i < 3; i++)
                begin
                    j = i;
                end
            end
            if_and_loop_PROC_STATE_next = 1; return;    // test_level2.cpp:405:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : if_and_loop_ff
    if ( ~nrst ) begin
        integer j;
        j = 0;
        if_and_loop_PROC_STATE <= 0;    // test_level2.cpp:397:9;
    end
    else begin
        if_and_loop_PROC_STATE <= if_and_loop_PROC_STATE_next;
    end
end

endmodule



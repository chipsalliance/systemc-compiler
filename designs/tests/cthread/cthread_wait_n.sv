//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: test_mod ()
//
module test_mod // "tmod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;
logic a;
logic [3:0] usig;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next;

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_reset_decl (test_cthread_wait_n.cpp:91:5) 

// Thread-local variables
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER;
logic [1:0] wait_n_reset_decl_WAIT_N_COUNTER_next;
logic wait_n_reset_decl_PROC_STATE;
logic wait_n_reset_decl_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_reset_decl_comb     // test_cthread_wait_n.cpp:91:5
    wait_n_reset_decl_func;
end
function void wait_n_reset_decl_func;
    wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER;
    wait_n_reset_decl_PROC_STATE_next = wait_n_reset_decl_PROC_STATE;
    
    case (wait_n_reset_decl_PROC_STATE)
        0: begin
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:98:13;
        end
        1: begin
            if (wait_n_reset_decl_WAIT_N_COUNTER != 1) begin
                wait_n_reset_decl_WAIT_N_COUNTER_next = wait_n_reset_decl_WAIT_N_COUNTER - 1;
                wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:98:13;
            end;
            wait_n_reset_decl_WAIT_N_COUNTER_next = 2;
            wait_n_reset_decl_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:98:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_reset_decl_ff
    if ( ~rstn ) begin
        integer unsigned k;
        integer unsigned i;
        k = 1;
        i = k + 1;
        wait_n_reset_decl_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:95:9;
        wait_n_reset_decl_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_reset_decl_WAIT_N_COUNTER <= wait_n_reset_decl_WAIT_N_COUNTER_next;
        wait_n_reset_decl_PROC_STATE <= wait_n_reset_decl_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: one_wait_n (test_cthread_wait_n.cpp:102:5) 

// Thread-local variables
logic [1:0] one_wait_n_WAIT_N_COUNTER;
logic [1:0] one_wait_n_WAIT_N_COUNTER_next;
logic [1:0] i0;
logic [1:0] i_next;
logic [1:0] one_wait_n_PROC_STATE;
logic [1:0] one_wait_n_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : one_wait_n_comb     // test_cthread_wait_n.cpp:102:5
    one_wait_n_func;
end
function void one_wait_n_func;
    i_next = i0;
    one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER;
    one_wait_n_PROC_STATE_next = one_wait_n_PROC_STATE;
    
    case (one_wait_n_PROC_STATE)
        0: begin
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:106:13;
        end
        1: begin
            i_next++;
            one_wait_n_WAIT_N_COUNTER_next = 2;
            one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:108:13;
        end
        2: begin
            if (one_wait_n_WAIT_N_COUNTER != 1) begin
                one_wait_n_WAIT_N_COUNTER_next = one_wait_n_WAIT_N_COUNTER - 1;
                one_wait_n_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:108:13;
            end;
            one_wait_n_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:106:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : one_wait_n_ff
    if ( ~rstn ) begin
        i0 <= 0;
        one_wait_n_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:104:9;
        one_wait_n_WAIT_N_COUNTER <= 0;
    end
    else begin
        one_wait_n_WAIT_N_COUNTER <= one_wait_n_WAIT_N_COUNTER_next;
        i0 <= i_next;
        one_wait_n_PROC_STATE <= one_wait_n_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread0 (test_cthread_wait_n.cpp:112:5) 

// Thread-local variables
logic [1:0] thread0_WAIT_N_COUNTER;
logic [1:0] thread0_WAIT_N_COUNTER_next;
logic [1:0] thread0_PROC_STATE;
logic [1:0] thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread0_comb     // test_cthread_wait_n.cpp:112:5
    thread0_func;
end
function void thread0_func;
    thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER;
    thread0_PROC_STATE_next = thread0_PROC_STATE;
    
    case (thread0_PROC_STATE)
        0: begin
            thread0_WAIT_N_COUNTER_next = 1;
            thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:115:13;
        end
        1: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:115:13;
            end;
            thread0_WAIT_N_COUNTER_next = 2;
            thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:116:13;
        end
        2: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:116:13;
            end;
            thread0_WAIT_N_COUNTER_next = 3;
            thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:117:13;
        end
        3: begin
            if (thread0_WAIT_N_COUNTER != 1) begin
                thread0_WAIT_N_COUNTER_next = thread0_WAIT_N_COUNTER - 1;
                thread0_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:117:13;
            end;
            thread0_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:114:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread0_ff
    if ( ~rstn ) begin
        thread0_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:114:13;
        thread0_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread0_WAIT_N_COUNTER <= thread0_WAIT_N_COUNTER_next;
        thread0_PROC_STATE <= thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_first (test_cthread_wait_n.cpp:123:5) 

// Thread-local variables
logic [1:0] thread_waitn_first_WAIT_N_COUNTER;
logic [1:0] thread_waitn_first_WAIT_N_COUNTER_next;
logic [3:0] usig_next;
logic thread_waitn_first_PROC_STATE;
logic thread_waitn_first_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_first_comb     // test_cthread_wait_n.cpp:123:5
    thread_waitn_first_func;
end
function void thread_waitn_first_func;
    usig_next = usig;
    thread_waitn_first_WAIT_N_COUNTER_next = thread_waitn_first_WAIT_N_COUNTER;
    thread_waitn_first_PROC_STATE_next = thread_waitn_first_PROC_STATE;
    
    case (thread_waitn_first_PROC_STATE)
        0: begin
            if (thread_waitn_first_WAIT_N_COUNTER != 1) begin
                thread_waitn_first_WAIT_N_COUNTER_next = thread_waitn_first_WAIT_N_COUNTER - 1;
                thread_waitn_first_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:126:13;
            end;
            usig_next = 1;
            thread_waitn_first_WAIT_N_COUNTER_next = 3;
            thread_waitn_first_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:126:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_first_ff
    if ( ~rstn ) begin
        usig <= 0;
        thread_waitn_first_WAIT_N_COUNTER <= 3;
        thread_waitn_first_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:126:13;
    end
    else begin
        thread_waitn_first_WAIT_N_COUNTER <= thread_waitn_first_WAIT_N_COUNTER_next;
        usig <= usig_next;
        thread_waitn_first_PROC_STATE <= thread_waitn_first_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_no_reset (test_cthread_wait_n.cpp:131:5) 

// Thread-local variables
logic [3:0] usig_next0;

// Next-state combinational logic
always_comb begin : thread_waitn_no_reset_comb     // test_cthread_wait_n.cpp:131:5
    thread_waitn_no_reset_func;
end
function void thread_waitn_no_reset_func;
    usig_next0 = usig;
    usig_next0 = 1;
endfunction

// Synchronous register update
always_ff @(posedge clk) 
begin : thread_waitn_no_reset_ff
    begin
        usig <= usig_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_first_cond (test_cthread_wait_n.cpp:139:5) 

// Thread-local variables
logic [2:0] thread_waitn_first_cond_WAIT_N_COUNTER;
logic [2:0] thread_waitn_first_cond_WAIT_N_COUNTER_next;
logic signed [31:0] m;
logic signed [31:0] m_next;
logic [3:0] usig_next1;
logic thread_waitn_first_cond_PROC_STATE;
logic thread_waitn_first_cond_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_first_cond_comb     // test_cthread_wait_n.cpp:139:5
    thread_waitn_first_cond_func;
end
function void thread_waitn_first_cond_func;
    m_next = m;
    usig_next1 = usig;
    thread_waitn_first_cond_WAIT_N_COUNTER_next = thread_waitn_first_cond_WAIT_N_COUNTER;
    thread_waitn_first_cond_PROC_STATE_next = thread_waitn_first_cond_PROC_STATE;
    
    case (thread_waitn_first_cond_PROC_STATE)
        0: begin
            if (thread_waitn_first_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_first_cond_WAIT_N_COUNTER_next = thread_waitn_first_cond_WAIT_N_COUNTER - 1;
                thread_waitn_first_cond_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:146:17;
            end;
            usig_next1 = 1;
            thread_waitn_first_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:149:13;
        end
        1: begin
            thread_waitn_first_cond_WAIT_N_COUNTER_next = 5;
            thread_waitn_first_cond_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:146:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_first_cond_ff
    if ( ~rstn ) begin
        m <= 0;
        usig <= 0;
        thread_waitn_first_cond_WAIT_N_COUNTER <= 5;
        thread_waitn_first_cond_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:146:17;
    end
    else begin
        thread_waitn_first_cond_WAIT_N_COUNTER <= thread_waitn_first_cond_WAIT_N_COUNTER_next;
        m <= m_next;
        usig <= usig_next1;
        thread_waitn_first_cond_PROC_STATE <= thread_waitn_first_cond_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread_waitn_cond (test_cthread_wait_n.cpp:153:5) 

// Thread-local variables
logic [2:0] thread_waitn_cond_WAIT_N_COUNTER;
logic [2:0] thread_waitn_cond_WAIT_N_COUNTER_next;
logic [3:0] usig_next2;
logic [1:0] thread_waitn_cond_PROC_STATE;
logic [1:0] thread_waitn_cond_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread_waitn_cond_comb     // test_cthread_wait_n.cpp:153:5
    thread_waitn_cond_func;
end
function void thread_waitn_cond_func;
    usig_next2 = usig;
    thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER;
    thread_waitn_cond_PROC_STATE_next = thread_waitn_cond_PROC_STATE;
    
    case (thread_waitn_cond_PROC_STATE)
        0: begin
            usig_next2 = 1;
            if (a)
            begin
                thread_waitn_cond_WAIT_N_COUNTER_next = 3;
                thread_waitn_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:159:17;
            end else begin
                thread_waitn_cond_WAIT_N_COUNTER_next = 5;
                thread_waitn_cond_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:161:17;
            end
        end
        1: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:159:17;
            end;
            thread_waitn_cond_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:156:13;
        end
        2: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:161:17;
            end;
            usig_next2 = 2;
            thread_waitn_cond_WAIT_N_COUNTER_next = 2;
            thread_waitn_cond_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:163:17;
        end
        3: begin
            if (thread_waitn_cond_WAIT_N_COUNTER != 1) begin
                thread_waitn_cond_WAIT_N_COUNTER_next = thread_waitn_cond_WAIT_N_COUNTER - 1;
                thread_waitn_cond_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:163:17;
            end;
            thread_waitn_cond_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:156:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread_waitn_cond_ff
    if ( ~rstn ) begin
        usig <= 0;
        thread_waitn_cond_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:156:13;
        thread_waitn_cond_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread_waitn_cond_WAIT_N_COUNTER <= thread_waitn_cond_WAIT_N_COUNTER_next;
        usig <= usig_next2;
        thread_waitn_cond_PROC_STATE <= thread_waitn_cond_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1a (test_cthread_wait_n.cpp:168:5) 

// Thread-local variables
logic [1:0] thread1a_WAIT_N_COUNTER;
logic [1:0] thread1a_WAIT_N_COUNTER_next;
logic thread1a_PROC_STATE;
logic thread1a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1a_comb     // test_cthread_wait_n.cpp:168:5
    thread1a_func;
end
function void thread1a_func;
    thread1a_WAIT_N_COUNTER_next = thread1a_WAIT_N_COUNTER;
    thread1a_PROC_STATE_next = thread1a_PROC_STATE;
    
    case (thread1a_PROC_STATE)
        0: begin
            thread1a_WAIT_N_COUNTER_next = 3;
            thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:171:13;
        end
        1: begin
            if (thread1a_WAIT_N_COUNTER != 1) begin
                thread1a_WAIT_N_COUNTER_next = thread1a_WAIT_N_COUNTER - 1;
                thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:171:13;
            end;
            thread1a_WAIT_N_COUNTER_next = 3;
            thread1a_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:171:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1a_ff
    if ( ~rstn ) begin
        thread1a_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:169:9;
        thread1a_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1a_WAIT_N_COUNTER <= thread1a_WAIT_N_COUNTER_next;
        thread1a_PROC_STATE <= thread1a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1b (test_cthread_wait_n.cpp:175:5) 

// Thread-local variables
logic [1:0] thread1b_WAIT_N_COUNTER;
logic [1:0] thread1b_WAIT_N_COUNTER_next;
logic thread1b_PROC_STATE;
logic thread1b_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1b_comb     // test_cthread_wait_n.cpp:175:5
    thread1b_func;
end
function void thread1b_func;
    integer i;
    thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER;
    thread1b_PROC_STATE_next = thread1b_PROC_STATE;
    
    case (thread1b_PROC_STATE)
        0: begin
            i = 0;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:179:13;
        end
        1: begin
            if (thread1b_WAIT_N_COUNTER != 1) begin
                thread1b_WAIT_N_COUNTER_next = thread1b_WAIT_N_COUNTER - 1;
                thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:179:13;
            end;
            i = 0;
            thread1b_WAIT_N_COUNTER_next = 3;
            thread1b_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:179:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1b_ff
    if ( ~rstn ) begin
        thread1b_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:176:9;
        thread1b_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1b_WAIT_N_COUNTER <= thread1b_WAIT_N_COUNTER_next;
        thread1b_PROC_STATE <= thread1b_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1c (test_cthread_wait_n.cpp:183:5) 

// Thread-local variables
logic [1:0] thread1c_WAIT_N_COUNTER;
logic [1:0] thread1c_WAIT_N_COUNTER_next;
logic thread1c_PROC_STATE;
logic thread1c_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1c_comb     // test_cthread_wait_n.cpp:183:5
    thread1c_func;
end
function void thread1c_func;
    integer i;
    thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER;
    thread1c_PROC_STATE_next = thread1c_PROC_STATE;
    
    case (thread1c_PROC_STATE)
        0: begin
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:186:13;
        end
        1: begin
            if (thread1c_WAIT_N_COUNTER != 1) begin
                thread1c_WAIT_N_COUNTER_next = thread1c_WAIT_N_COUNTER - 1;
                thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:186:13;
            end;
            i = 0;
            thread1c_WAIT_N_COUNTER_next = 3;
            thread1c_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:186:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1c_ff
    if ( ~rstn ) begin
        thread1c_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:184:9;
        thread1c_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1c_WAIT_N_COUNTER <= thread1c_WAIT_N_COUNTER_next;
        thread1c_PROC_STATE <= thread1c_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread1d (test_cthread_wait_n.cpp:191:5) 

// Thread-local variables
logic [1:0] thread1d_WAIT_N_COUNTER;
logic [1:0] thread1d_WAIT_N_COUNTER_next;
logic thread1d_PROC_STATE;
logic thread1d_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread1d_comb     // test_cthread_wait_n.cpp:191:5
    thread1d_func;
end
function void thread1d_func;
    thread1d_WAIT_N_COUNTER_next = thread1d_WAIT_N_COUNTER;
    thread1d_PROC_STATE_next = thread1d_PROC_STATE;
    
    case (thread1d_PROC_STATE)
        0: begin
            thread1d_WAIT_N_COUNTER_next = 3;
            thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:195:13;
        end
        1: begin
            if (thread1d_WAIT_N_COUNTER != 1) begin
                thread1d_WAIT_N_COUNTER_next = thread1d_WAIT_N_COUNTER - 1;
                thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:195:13;
            end;
            thread1d_WAIT_N_COUNTER_next = 3;
            thread1d_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:195:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread1d_ff
    if ( ~rstn ) begin
        integer i;
        i = 1;
        thread1d_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:193:9;
        thread1d_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread1d_WAIT_N_COUNTER <= thread1d_WAIT_N_COUNTER_next;
        thread1d_PROC_STATE <= thread1d_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread2 (test_cthread_wait_n.cpp:199:5) 

// Thread-local variables
logic [2:0] thread2_WAIT_N_COUNTER;
logic [2:0] thread2_WAIT_N_COUNTER_next;
logic thread2_PROC_STATE;
logic thread2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread2_comb     // test_cthread_wait_n.cpp:199:5
    thread2_func;
end
function void thread2_func;
    thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER;
    thread2_PROC_STATE_next = thread2_PROC_STATE;
    
    case (thread2_PROC_STATE)
        0: begin
            if (thread2_WAIT_N_COUNTER != 1) begin
                thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER - 1;
                thread2_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:201:13;
            end;
            thread2_WAIT_N_COUNTER_next = 1 + 1 + 1;
            thread2_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:202:13;
        end
        1: begin
            if (thread2_WAIT_N_COUNTER != 1) begin
                thread2_WAIT_N_COUNTER_next = thread2_WAIT_N_COUNTER - 1;
                thread2_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:202:13;
            end;
            thread2_WAIT_N_COUNTER_next = 2 * 2;
            thread2_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:201:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread2_ff
    if ( ~rstn ) begin
        thread2_WAIT_N_COUNTER <= 2 * 2;
        thread2_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:201:13;
    end
    else begin
        thread2_WAIT_N_COUNTER <= thread2_WAIT_N_COUNTER_next;
        thread2_PROC_STATE <= thread2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread3 (test_cthread_wait_n.cpp:206:5) 

// Thread-local variables
logic [1:0] thread3_WAIT_N_COUNTER;
logic [1:0] thread3_WAIT_N_COUNTER_next;
logic signed [31:0] n;
logic signed [31:0] n_next;
logic [1:0] thread3_PROC_STATE;
logic [1:0] thread3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread3_comb     // test_cthread_wait_n.cpp:206:5
    thread3_func;
end
function void thread3_func;
    n_next = n;
    thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER;
    thread3_PROC_STATE_next = thread3_PROC_STATE;
    
    case (thread3_PROC_STATE)
        0: begin
            n_next = 2;
            thread3_WAIT_N_COUNTER_next = n_next;
            thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:213:13;
        end
        1: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:213:13;
            end;
            thread3_WAIT_N_COUNTER_next = n_next + 1;
            thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:214:13;
        end
        2: begin
            if (thread3_WAIT_N_COUNTER != 1) begin
                thread3_WAIT_N_COUNTER_next = thread3_WAIT_N_COUNTER - 1;
                thread3_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:214:13;
            end;
            thread3_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:211:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread3_ff
    if ( ~rstn ) begin
        thread3_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:211:13;
        thread3_WAIT_N_COUNTER <= 0;
    end
    else begin
        thread3_WAIT_N_COUNTER <= thread3_WAIT_N_COUNTER_next;
        n <= n_next;
        thread3_PROC_STATE <= thread3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: thread4_no_waitn (test_cthread_wait_n.cpp:218:5) 

// Thread-local variables
logic [63:0] i1;
logic [63:0] i_next0;
logic thread4_no_waitn_PROC_STATE;
logic thread4_no_waitn_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : thread4_no_waitn_comb     // test_cthread_wait_n.cpp:218:5
    thread4_no_waitn_func;
end
function void thread4_no_waitn_func;
    i_next0 = i1;
    thread4_no_waitn_PROC_STATE_next = thread4_no_waitn_PROC_STATE;
    
    case (thread4_no_waitn_PROC_STATE)
        0: begin
            i_next0 = 0;
            thread4_no_waitn_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:222:17;
        end
        1: begin
            ++i_next0;
            if (i_next0 < 3)
            begin
                thread4_no_waitn_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:222:17;
            end
            thread4_no_waitn_PROC_STATE_next = 0; return;    // test_cthread_wait_n.cpp:220:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : thread4_no_waitn_ff
    if ( ~rstn ) begin
        thread4_no_waitn_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:220:13;
    end
    else begin
        i1 <= i_next0;
        thread4_no_waitn_PROC_STATE <= thread4_no_waitn_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_const (test_cthread_wait_n.cpp:227:5) 

// Thread-local variables
logic [1:0] wait_n_const_WAIT_N_COUNTER;
logic [1:0] wait_n_const_WAIT_N_COUNTER_next;
logic wait_n_const_PROC_STATE;
logic wait_n_const_PROC_STATE_next;

// Thread-local constants
logic [31:0] n0;

// Next-state combinational logic
always_comb begin : wait_n_const_comb     // test_cthread_wait_n.cpp:227:5
    wait_n_const_func;
end
function void wait_n_const_func;
    wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER;
    wait_n_const_PROC_STATE_next = wait_n_const_PROC_STATE;
    
    case (wait_n_const_PROC_STATE)
        0: begin
            wait_n_const_WAIT_N_COUNTER_next = n0;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:13;
        end
        1: begin
            if (wait_n_const_WAIT_N_COUNTER != 1) begin
                wait_n_const_WAIT_N_COUNTER_next = wait_n_const_WAIT_N_COUNTER - 1;
                wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:13;
            end;
            wait_n_const_WAIT_N_COUNTER_next = n0;
            wait_n_const_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:232:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_const_ff
    if ( ~rstn ) begin
        n0 = 2;
        wait_n_const_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:229:9;
        wait_n_const_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_const_WAIT_N_COUNTER <= wait_n_const_WAIT_N_COUNTER_next;
        wait_n_const_PROC_STATE <= wait_n_const_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_var (test_cthread_wait_n.cpp:236:5) 

// Thread-local variables
logic [1:0] wait_n_var_WAIT_N_COUNTER;
logic [1:0] wait_n_var_WAIT_N_COUNTER_next;
logic wait_n_var_PROC_STATE;
logic wait_n_var_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_var_comb     // test_cthread_wait_n.cpp:236:5
    wait_n_var_func;
end
function void wait_n_var_func;
    integer unsigned n_1;
    wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER;
    wait_n_var_PROC_STATE_next = wait_n_var_PROC_STATE;
    
    case (wait_n_var_PROC_STATE)
        0: begin
            n_1 = 2;
            wait_n_var_WAIT_N_COUNTER_next = n_1;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:242:13;
        end
        1: begin
            if (wait_n_var_WAIT_N_COUNTER != 1) begin
                wait_n_var_WAIT_N_COUNTER_next = wait_n_var_WAIT_N_COUNTER - 1;
                wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:242:13;
            end;
            n_1 = 2;
            wait_n_var_WAIT_N_COUNTER_next = n_1;
            wait_n_var_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:242:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_var_ff
    if ( ~rstn ) begin
        integer unsigned n_1;
        n_1 = 0;
        wait_n_var_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:238:9;
        wait_n_var_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_var_WAIT_N_COUNTER <= wait_n_var_WAIT_N_COUNTER_next;
        wait_n_var_PROC_STATE <= wait_n_var_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc (test_cthread_wait_n.cpp:246:5) 

// Thread-local variables
logic [2:0] wait_n_calc_WAIT_N_COUNTER;
logic [2:0] wait_n_calc_WAIT_N_COUNTER_next;
logic [31:0] n1;
logic [31:0] n_next0;
logic [1:0] wait_n_calc_PROC_STATE;
logic [1:0] wait_n_calc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_comb     // test_cthread_wait_n.cpp:246:5
    wait_n_calc_func;
end
function void wait_n_calc_func;
    integer unsigned m_1;
    n_next0 = n1;
    wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER;
    wait_n_calc_PROC_STATE_next = wait_n_calc_PROC_STATE;
    
    case (wait_n_calc_PROC_STATE)
        0: begin
            n_next0 = 2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:253:13;
        end
        1: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:253:13;
            end;
            n_next0++;
            m_1 = 1;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 + m_1;
            wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:256:13;
        end
        2: begin
            if (wait_n_calc_WAIT_N_COUNTER != 1) begin
                wait_n_calc_WAIT_N_COUNTER_next = wait_n_calc_WAIT_N_COUNTER - 1;
                wait_n_calc_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:256:13;
            end;
            n_next0 = 2;
            wait_n_calc_WAIT_N_COUNTER_next = n_next0 - 1;
            wait_n_calc_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:253:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_ff
    if ( ~rstn ) begin
        wait_n_calc_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:249:9;
        wait_n_calc_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_WAIT_N_COUNTER <= wait_n_calc_WAIT_N_COUNTER_next;
        n1 <= n_next0;
        wait_n_calc_PROC_STATE <= wait_n_calc_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_if (test_cthread_wait_n.cpp:261:5) 

// Thread-local variables
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_if_WAIT_N_COUNTER_next;
logic [1:0] wait_n_calc_if_PROC_STATE;
logic [1:0] wait_n_calc_if_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_if_comb     // test_cthread_wait_n.cpp:261:5
    wait_n_calc_if_func;
end
function void wait_n_calc_if_func;
    integer unsigned n_1;
    wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER;
    wait_n_calc_if_PROC_STATE_next = wait_n_calc_if_PROC_STATE;
    
    case (wait_n_calc_if_PROC_STATE)
        0: begin
            n_1 = 2;
            if (a)
            begin
                wait_n_calc_if_WAIT_N_COUNTER_next = n_1++;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:268:27;
            end
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:270:13;
        end
        1: begin
            if (wait_n_calc_if_WAIT_N_COUNTER != 1) begin
                wait_n_calc_if_WAIT_N_COUNTER_next = wait_n_calc_if_WAIT_N_COUNTER - 1;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:268:27;
            end;
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:270:13;
        end
        2: begin
            n_1 = 2;
            if (a)
            begin
                wait_n_calc_if_WAIT_N_COUNTER_next = n_1++;
                wait_n_calc_if_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:268:27;
            end
            wait_n_calc_if_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:270:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_if_ff
    if ( ~rstn ) begin
        wait_n_calc_if_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:264:9;
        wait_n_calc_if_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_if_WAIT_N_COUNTER <= wait_n_calc_if_WAIT_N_COUNTER_next;
        wait_n_calc_if_PROC_STATE <= wait_n_calc_if_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_n_calc_for (test_cthread_wait_n.cpp:275:5) 

// Thread-local variables
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER;
logic [1:0] wait_n_calc_for_WAIT_N_COUNTER_next;
logic [31:0] n2;
logic [31:0] n_next1;
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic wait_n_calc_for_PROC_STATE;
logic wait_n_calc_for_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : wait_n_calc_for_comb     // test_cthread_wait_n.cpp:275:5
    wait_n_calc_for_func;
end
function void wait_n_calc_for_func;
    i_next1 = i2;
    n_next1 = n2;
    wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER;
    wait_n_calc_for_PROC_STATE_next = wait_n_calc_for_PROC_STATE;
    
    case (wait_n_calc_for_PROC_STATE)
        0: begin
            i_next1 = 0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:17;
        end
        1: begin
            if (wait_n_calc_for_WAIT_N_COUNTER != 1) begin
                wait_n_calc_for_WAIT_N_COUNTER_next = wait_n_calc_for_WAIT_N_COUNTER - 1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:17;
            end;
            i_next1++;
            if (i_next1 < 2)
            begin
                wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
                wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:17;
            end
            i_next1 = 0;
            wait_n_calc_for_WAIT_N_COUNTER_next = n_next1;
            wait_n_calc_for_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:282:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_n_calc_for_ff
    if ( ~rstn ) begin
        n2 <= 3;
        wait_n_calc_for_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:278:9;
        wait_n_calc_for_WAIT_N_COUNTER <= 0;
    end
    else begin
        wait_n_calc_for_WAIT_N_COUNTER <= wait_n_calc_for_WAIT_N_COUNTER_next;
        n2 <= n_next1;
        i2 <= i_next1;
        wait_n_calc_for_PROC_STATE <= wait_n_calc_for_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: three_wait (test_cthread_wait_n.cpp:287:5) 

// Thread-local variables
logic [1:0] three_wait_PROC_STATE;
logic [1:0] three_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : three_wait_comb     // test_cthread_wait_n.cpp:287:5
    three_wait_func;
end
function void three_wait_func;
    three_wait_PROC_STATE_next = three_wait_PROC_STATE;
    
    case (three_wait_PROC_STATE)
        0: begin
            three_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:292:13;
        end
        1: begin
            three_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:293:13;
        end
        2: begin
            three_wait_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:294:13;
        end
        3: begin
            three_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:292:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : three_wait_ff
    if ( ~rstn ) begin
        three_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:289:9;
    end
    else begin
        three_wait_PROC_STATE <= three_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: four_wait (test_cthread_wait_n.cpp:299:5) 

// Thread-local variables
logic [2:0] four_wait_PROC_STATE;
logic [2:0] four_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : four_wait_comb     // test_cthread_wait_n.cpp:299:5
    four_wait_func;
end
function void four_wait_func;
    four_wait_PROC_STATE_next = four_wait_PROC_STATE;
    
    case (four_wait_PROC_STATE)
        0: begin
            four_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:304:13;
        end
        1: begin
            four_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:305:13;
        end
        2: begin
            four_wait_PROC_STATE_next = 3; return;    // test_cthread_wait_n.cpp:306:13;
        end
        3: begin
            four_wait_PROC_STATE_next = 4; return;    // test_cthread_wait_n.cpp:307:13;
        end
        4: begin
            four_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:304:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : four_wait_ff
    if ( ~rstn ) begin
        four_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:301:9;
    end
    else begin
        four_wait_PROC_STATE <= four_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: cntr_name_conflict (test_cthread_wait_n.cpp:314:5) 

// Thread-local variables
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER0;
logic [1:0] cntr_name_conflict_WAIT_N_COUNTER_next0;
logic [2:0] cntr_name_conflict_WAIT_N_COUNTER_next_next;
logic cntr_name_conflict_WAIT_N_COUNTER;
logic cntr_name_conflict_WAIT_N_COUNTER_next1;
logic cntr_name_conflict_PROC_STATE;
logic cntr_name_conflict_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : cntr_name_conflict_comb     // test_cthread_wait_n.cpp:314:5
    cntr_name_conflict_func;
end
function void cntr_name_conflict_func;
    cntr_name_conflict_WAIT_N_COUNTER_next1 = cntr_name_conflict_WAIT_N_COUNTER;
    cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next;
    cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0;
    cntr_name_conflict_PROC_STATE_next = cntr_name_conflict_PROC_STATE;
    
    case (cntr_name_conflict_PROC_STATE)
        0: begin
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:323:13;
        end
        1: begin
            if (cntr_name_conflict_WAIT_N_COUNTER0 != 1) begin
                cntr_name_conflict_WAIT_N_COUNTER_next0 = cntr_name_conflict_WAIT_N_COUNTER0 - 1;
                cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:323:13;
            end;
            cntr_name_conflict_WAIT_N_COUNTER_next1 = !cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next_next = cntr_name_conflict_WAIT_N_COUNTER_next1;
            cntr_name_conflict_WAIT_N_COUNTER_next0 = 3;
            cntr_name_conflict_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:323:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : cntr_name_conflict_ff
    if ( ~rstn ) begin
        cntr_name_conflict_WAIT_N_COUNTER <= 0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER;
        cntr_name_conflict_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:318:9;
        cntr_name_conflict_WAIT_N_COUNTER0 <= 0;
    end
    else begin
        cntr_name_conflict_WAIT_N_COUNTER0 <= cntr_name_conflict_WAIT_N_COUNTER_next0;
        cntr_name_conflict_WAIT_N_COUNTER_next <= cntr_name_conflict_WAIT_N_COUNTER_next_next;
        cntr_name_conflict_WAIT_N_COUNTER <= cntr_name_conflict_WAIT_N_COUNTER_next1;
        cntr_name_conflict_PROC_STATE <= cntr_name_conflict_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: while_wait (test_cthread_wait_n.cpp:327:5) 

// Thread-local variables
logic [1:0] while_wait_WAIT_N_COUNTER;
logic [1:0] while_wait_WAIT_N_COUNTER_next;
logic [1:0] while_wait_PROC_STATE;
logic [1:0] while_wait_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : while_wait_comb     // test_cthread_wait_n.cpp:327:5
    while_wait_func;
end
function void while_wait_func;
    while_wait_WAIT_N_COUNTER_next = while_wait_WAIT_N_COUNTER;
    while_wait_PROC_STATE_next = while_wait_PROC_STATE;
    
    case (while_wait_PROC_STATE)
        0: begin
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:332:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:333:13;
        end
        1: begin
            if (while_wait_WAIT_N_COUNTER != 1) begin
                while_wait_WAIT_N_COUNTER_next = while_wait_WAIT_N_COUNTER - 1;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:332:23;
            end;
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:332:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:333:13;
        end
        2: begin
            if (a)
            begin
                while_wait_WAIT_N_COUNTER_next = 3;
                while_wait_PROC_STATE_next = 1; return;    // test_cthread_wait_n.cpp:332:23;
            end
            while_wait_PROC_STATE_next = 2; return;    // test_cthread_wait_n.cpp:333:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : while_wait_ff
    if ( ~rstn ) begin
        while_wait_PROC_STATE <= 0;    // test_cthread_wait_n.cpp:329:9;
        while_wait_WAIT_N_COUNTER <= 0;
    end
    else begin
        while_wait_WAIT_N_COUNTER <= while_wait_WAIT_N_COUNTER_next;
        while_wait_PROC_STATE <= while_wait_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: wait_1 (test_cthread_wait_n.cpp:338:5) 

// Thread-local variables
logic [31:0] nn;
logic [31:0] nn_next;

// Next-state combinational logic
always_comb begin : wait_1_comb     // test_cthread_wait_n.cpp:338:5
    wait_1_func;
end
function void wait_1_func;
    nn_next = nn;
    while_wait_WAIT_N_COUNTER_next = nn_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : wait_1_ff
    if ( ~rstn ) begin
        nn <= 1;
    end
    else begin
        nn <= nn_next;
    end
end

endmodule



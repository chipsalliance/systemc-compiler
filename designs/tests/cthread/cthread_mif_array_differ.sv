//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.16
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);

// Variables generated for SystemC signals
logic ar1_nrst[2];
logic br1_nrst[2];
logic ar2_nrst[2];
logic br2_nrst[2];
logic ar3_nrst[2];
logic br3_nrst[2];
logic ar1_clk[2];
logic br1_clk[2];
logic ar2_clk[2];
logic br2_clk[2];
logic ar3_clk[2];
logic br3_clk[2];

// Local parameters generated for C++ constants
localparam logic [31:0] ar1_V[2] = '{ 1, 2 };
localparam logic [31:0] ar1_C[2] = '{ 1, 2 };
localparam logic [31:0] br1_V[2] = '{ 1, 2 };
localparam logic [31:0] ar2_V[2] = '{ 1, 2 };
localparam logic [31:0] ar2_C[2] = '{ 1, 2 };
localparam logic [31:0] br2_V[2] = '{ 1, 2 };
localparam logic [31:0] ar3_V[2] = '{ 1, 2 };
localparam logic [31:0] ar3_C[2] = '{ 0, 0 };
localparam logic [31:0] br3_V[2] = '{ 1, 2 };

// Assignments generated for C++ channel arrays
assign ar1_clk[0] = clk;
assign ar1_clk[1] = clk;
assign br1_clk[0] = clk;
assign br1_clk[1] = clk;
assign ar2_clk[0] = clk;
assign ar2_clk[1] = clk;
assign br2_clk[0] = clk;
assign br2_clk[1] = clk;
assign ar3_clk[0] = clk;
assign ar3_clk[1] = clk;
assign br3_clk[0] = clk;
assign br3_clk[1] = clk;

//------------------------------------------------------------------------------
// Clocked THREAD: ar1_proc (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar1_proc_comb     // test_mif_array_differ.cpp:33:5
    ar1_proc_func;
end
function void ar1_proc_func;
    integer unsigned l;
    l = ar1_V[0] + ar1_C[0];
endfunction

// Synchronous register update
always_ff @(posedge ar1_clk[0] or negedge ar1_nrst[0]) 
begin : ar1_proc_ff
    if ( ~ar1_nrst[0] ) begin
        integer unsigned l;
        l = ar1_V[0];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ar1_proc0 (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar1_proc0_comb     // test_mif_array_differ.cpp:33:5
    ar1_proc0_func;
end
function void ar1_proc0_func;
    integer unsigned l;
    l = ar1_V[1] + ar1_C[1];
endfunction

// Synchronous register update
always_ff @(posedge ar1_clk[1] or negedge ar1_nrst[1]) 
begin : ar1_proc0_ff
    if ( ~ar1_nrst[1] ) begin
        integer unsigned l;
        l = ar1_V[1];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br1_proc (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE;
logic proc_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : br1_proc_comb     // test_mif_array_differ.cpp:60:5
    br1_proc_func;
end
function void br1_proc_func;
    integer unsigned l;
    proc_PROC_STATE_next = proc_PROC_STATE;
    
    case (proc_PROC_STATE)
        0: begin
            l = br1_V[0];
            proc_PROC_STATE_next = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br1_V[0] + 1;
            l = br1_V[0];
            proc_PROC_STATE_next = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br1_clk[0] or negedge br1_nrst[0]) 
begin : br1_proc_ff
    if ( ~br1_nrst[0] ) begin
        proc_PROC_STATE <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE <= proc_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br1_proc0 (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE0;
logic proc_PROC_STATE_next0;

// Next-state combinational logic
always_comb begin : br1_proc0_comb     // test_mif_array_differ.cpp:60:5
    br1_proc0_func;
end
function void br1_proc0_func;
    integer unsigned l;
    proc_PROC_STATE_next0 = proc_PROC_STATE0;
    
    case (proc_PROC_STATE0)
        0: begin
            l = br1_V[1];
            proc_PROC_STATE_next0 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br1_V[1] + 1;
            l = br1_V[1];
            proc_PROC_STATE_next0 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br1_clk[1] or negedge br1_nrst[1]) 
begin : br1_proc0_ff
    if ( ~br1_nrst[1] ) begin
        proc_PROC_STATE0 <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE0 <= proc_PROC_STATE_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ar2_proc (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar2_proc_comb     // test_mif_array_differ.cpp:33:5
    ar2_proc_func;
end
function void ar2_proc_func;
    integer unsigned l;
    l = ar2_V[0] + ar2_C[0];
endfunction

// Synchronous register update
always_ff @(posedge ar2_clk[0] or negedge ar2_nrst[0]) 
begin : ar2_proc_ff
    if ( ~ar2_nrst[0] ) begin
        integer unsigned l;
        l = ar2_V[0];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ar2_proc0 (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar2_proc0_comb     // test_mif_array_differ.cpp:33:5
    ar2_proc0_func;
end
function void ar2_proc0_func;
    integer unsigned l;
    l = ar2_V[1] + ar2_C[1];
endfunction

// Synchronous register update
always_ff @(posedge ar2_clk[1] or negedge ar2_nrst[1]) 
begin : ar2_proc0_ff
    if ( ~ar2_nrst[1] ) begin
        integer unsigned l;
        l = ar2_V[1];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br2_proc (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE1;
logic proc_PROC_STATE_next1;

// Next-state combinational logic
always_comb begin : br2_proc_comb     // test_mif_array_differ.cpp:60:5
    br2_proc_func;
end
function void br2_proc_func;
    integer unsigned l;
    proc_PROC_STATE_next1 = proc_PROC_STATE1;
    
    case (proc_PROC_STATE1)
        0: begin
            l = br2_V[0];
            proc_PROC_STATE_next1 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br2_V[0] + 1;
            l = br2_V[0];
            proc_PROC_STATE_next1 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br2_clk[0] or negedge br2_nrst[0]) 
begin : br2_proc_ff
    if ( ~br2_nrst[0] ) begin
        proc_PROC_STATE1 <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE1 <= proc_PROC_STATE_next1;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br2_proc0 (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE2;
logic proc_PROC_STATE_next2;

// Next-state combinational logic
always_comb begin : br2_proc0_comb     // test_mif_array_differ.cpp:60:5
    br2_proc0_func;
end
function void br2_proc0_func;
    integer unsigned l;
    proc_PROC_STATE_next2 = proc_PROC_STATE2;
    
    case (proc_PROC_STATE2)
        0: begin
            l = br2_V[1];
            proc_PROC_STATE_next2 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br2_V[1] + 1;
            l = br2_V[1];
            proc_PROC_STATE_next2 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br2_clk[1] or negedge br2_nrst[1]) 
begin : br2_proc0_ff
    if ( ~br2_nrst[1] ) begin
        proc_PROC_STATE2 <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE2 <= proc_PROC_STATE_next2;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ar3_proc (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar3_proc_comb     // test_mif_array_differ.cpp:33:5
    ar3_proc_func;
end
function void ar3_proc_func;
    integer unsigned l;
    l = ar3_V[0] + ar3_C[0];
endfunction

// Synchronous register update
always_ff @(posedge ar3_clk[0] or negedge ar3_nrst[0]) 
begin : ar3_proc_ff
    if ( ~ar3_nrst[0] ) begin
        integer unsigned l;
        l = ar3_V[0];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: ar3_proc0 (test_mif_array_differ.cpp:33:5) 

// Next-state combinational logic
always_comb begin : ar3_proc0_comb     // test_mif_array_differ.cpp:33:5
    ar3_proc0_func;
end
function void ar3_proc0_func;
    integer unsigned l;
    l = ar3_V[1] + ar3_C[1];
endfunction

// Synchronous register update
always_ff @(posedge ar3_clk[1] or negedge ar3_nrst[1]) 
begin : ar3_proc0_ff
    if ( ~ar3_nrst[1] ) begin
        integer unsigned l;
        l = ar3_V[1];
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br3_proc (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE3;
logic proc_PROC_STATE_next3;

// Next-state combinational logic
always_comb begin : br3_proc_comb     // test_mif_array_differ.cpp:60:5
    br3_proc_func;
end
function void br3_proc_func;
    integer unsigned l;
    proc_PROC_STATE_next3 = proc_PROC_STATE3;
    
    case (proc_PROC_STATE3)
        0: begin
            l = br3_V[0];
            proc_PROC_STATE_next3 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br3_V[0] + 1;
            l = br3_V[0];
            proc_PROC_STATE_next3 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br3_clk[0] or negedge br3_nrst[0]) 
begin : br3_proc_ff
    if ( ~br3_nrst[0] ) begin
        proc_PROC_STATE3 <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE3 <= proc_PROC_STATE_next3;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: br3_proc0 (test_mif_array_differ.cpp:60:5) 

// Thread-local variables
logic proc_PROC_STATE4;
logic proc_PROC_STATE_next4;

// Next-state combinational logic
always_comb begin : br3_proc0_comb     // test_mif_array_differ.cpp:60:5
    br3_proc0_func;
end
function void br3_proc0_func;
    integer unsigned l;
    proc_PROC_STATE_next4 = proc_PROC_STATE4;
    
    case (proc_PROC_STATE4)
        0: begin
            l = br3_V[1];
            proc_PROC_STATE_next4 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
        1: begin
            l = br3_V[1] + 1;
            l = br3_V[1];
            proc_PROC_STATE_next4 = 1; return;    // test_mif_array_differ.cpp:65:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge br3_clk[1] or negedge br3_nrst[1]) 
begin : br3_proc0_ff
    if ( ~br3_nrst[1] ) begin
        proc_PROC_STATE4 <= 0;    // test_mif_array_differ.cpp:62:9;
    end
    else begin
        proc_PROC_STATE4 <= proc_PROC_STATE_next4;
    end
end

endmodule



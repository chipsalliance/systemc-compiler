//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.23
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_ptr_arr_cthread.cpp:94:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic signed [31:0] s;

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_simple (test_ptr_arr_cthread.cpp:50:5) 

// Thread-local variables
logic r1_a[2];
logic r1_a_next[2];

// Next-state combinational logic
always_comb begin : rec_ptr_simple_comb     // test_ptr_arr_cthread.cpp:50:5
    rec_ptr_simple_func;
end
function void rec_ptr_simple_func;
    logic b;
    logic TMP_0;
    r1_a_next = r1_a;
    b = r1_a_next[0];
    // Call getA() begin
    TMP_0 = r1_a_next[s];
    // Call getA() end
    b = TMP_0;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_simple_ff
    if ( ~rst ) begin
    end
    else begin
        r1_a <= r1_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_loop (test_ptr_arr_cthread.cpp:61:5) 

// Thread-local variables
logic r2_a[2];
logic r2_a_next[2];
logic [3:0] r2_b[2];

// Next-state combinational logic
always_comb begin : rec_ptr_loop_comb     // test_ptr_arr_cthread.cpp:61:5
    rec_ptr_loop_func;
end
function void rec_ptr_loop_func;
    logic b;
    logic [3:0] par;
    r2_a_next = r2_a;
    b = 0;
    for (integer i = 0; i < 2; i++)
    begin
        b = b || 0;
        par = i;
        // Call setB() begin
        r2_b[i] = par;
        // Call setB() end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_loop_ff
    if ( ~rst ) begin
    end
    else begin
        r2_a <= r2_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_ptr_unknw (test_ptr_arr_cthread.cpp:77:5) 

// Thread-local variables
logic r3_a[2];
logic r3_a_next[2];
logic [3:0] r3_b[2];
logic [3:0] r3_b_next[2];

// Next-state combinational logic
always_comb begin : rec_ptr_unknw_comb     // test_ptr_arr_cthread.cpp:77:5
    rec_ptr_unknw_func;
end
function void rec_ptr_unknw_func;
    integer i;
    logic b;
    logic [3:0] c;
    logic [3:0] par;
    r3_a_next = r3_a;
    r3_b_next = r3_b;
    i = s;
    b = r3_a_next[i];
    c = r3_b_next[i + 1];
    par = i + 2;
    // Call setB() begin
    r3_b_next[i] = par;
    // Call setB() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rst) 
begin : rec_ptr_unknw_ff
    if ( ~rst ) begin
    end
    else begin
        r3_a <= r3_a_next;
        r3_b <= r3_b_next;
    end
end

endmodule



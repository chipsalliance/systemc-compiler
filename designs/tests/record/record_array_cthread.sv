//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.18
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_array_cthread.cpp:730:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] sig;

// Local parameters generated for C++ constants
localparam logic signed [31:0] ap_b = 11;

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr_declare (test_array_cthread.cpp:137:5) 

// Thread-local variables
logic [3:0] ad_b[2];
logic [3:0] ad_b_next[2];

// Next-state combinational logic
always_comb begin : rec_loc_arr_declare_comb     // test_array_cthread.cpp:137:5
    rec_loc_arr_declare_func;
end
function void rec_loc_arr_declare_func;
    logic signed [1:0] ad_a[2];
    logic [3:0] i;
    ad_b_next = ad_b;
    i = ad_b_next[0];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr_declare_ff
    if ( ~nrst ) begin
    end
    else begin
        ad_b <= ad_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr0 (test_array_cthread.cpp:154:5) 

// Next-state combinational logic
always_comb begin : rec_loc_arr0_comb     // test_array_cthread.cpp:154:5
    rec_loc_arr0_func;
end
function void rec_loc_arr0_func;
    logic signed [1:0] ap_a[2];
    logic [3:0] ap_b_1[2];
    integer i;
    ap_b_1[1] = 1;
    ap_b_1[0] = ap_b_1[1] + ap_b;
    i = ap_b_1[0];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr0_ff
    if ( ~nrst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr0a (test_array_cthread.cpp:173:5) 

// Thread-local variables
logic signed [31:0] ar_b;
logic signed [31:0] ar_b_next;
logic [3:0] ar_b0[2];
logic [3:0] ar_b_next0[2];
logic rec_loc_arr0a_PROC_STATE;
logic rec_loc_arr0a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr0a_comb     // test_array_cthread.cpp:173:5
    rec_loc_arr0a_func;
end
function void rec_loc_arr0a_func;
    logic signed [1:0] ar_a[2];
    ar_b_next = ar_b;
    ar_b_next0 = ar_b0;
    rec_loc_arr0a_PROC_STATE_next = rec_loc_arr0a_PROC_STATE;
    
    case (rec_loc_arr0a_PROC_STATE)
        0: begin
            ar_b_next0[1] = sig - 1;
            ar_b_next = sig + 1;
            rec_loc_arr0a_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:181:13;
        end
        1: begin
            ar_b_next0[0] = ar_b_next0[1] - ar_b_next;
            ar_b_next0[1] = sig - 1;
            ar_b_next = sig + 1;
            rec_loc_arr0a_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:181:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr0a_ff
    if ( ~nrst ) begin
        rec_loc_arr0a_PROC_STATE <= 0;    // test_array_cthread.cpp:175:9;
    end
    else begin
        ar_b <= ar_b_next;
        ar_b0 <= ar_b_next0;
        rec_loc_arr0a_PROC_STATE <= rec_loc_arr0a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr1 (test_array_cthread.cpp:188:5) 

// Thread-local variables
logic [3:0] br_b[2];
logic [3:0] br_b_next[2];

// Next-state combinational logic
always_comb begin : rec_loc_arr1_comb     // test_array_cthread.cpp:188:5
    rec_loc_arr1_func;
end
function void rec_loc_arr1_func;
    logic signed [1:0] br_a[2];
    integer i;
    br_b_next = br_b;
    i = sig;
    br_a[i] = 1;
    br_b_next[i + 1] = br_b_next[i] - 1;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr1_ff
    if ( ~nrst ) begin
    end
    else begin
        br_b <= br_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr2 (test_array_cthread.cpp:202:5) 

// Thread-local variables
logic [3:0] crr_b[2][3];
logic [3:0] crr_b_next[2][3];

// Next-state combinational logic
always_comb begin : rec_loc_arr2_comb     // test_array_cthread.cpp:202:5
    rec_loc_arr2_func;
end
function void rec_loc_arr2_func;
    logic signed [1:0] cr_a[2];
    logic [3:0] cr_b[2];
    logic signed [1:0] crr_a[2][3];
    integer c;
    crr_b_next = crr_b;
    cr_a[1] = 2;
    crr_a[1][2] = cr_a[1];
    cr_b[0] = 42;
    c = crr_b_next[1][0] + cr_b[0];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr2_ff
    if ( ~nrst ) begin
    end
    else begin
        crr_b <= crr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean (test_array_cthread.cpp:218:5) 

// Thread-local variables
logic signed [31:0] k;
logic signed [31:0] k_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean_comb     // test_array_cthread.cpp:218:5
    code_scope_state_clean_func;
end
function void code_scope_state_clean_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    integer j;
    k_next = k;
    dd_a[k_next] = 1;
    j = k_next;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean_ff
    if ( ~nrst ) begin
        k <= sig;
    end
    else begin
        k <= k_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean1 (test_array_cthread.cpp:235:5) 

// Thread-local variables
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic [1:0] code_scope_state_clean1_PROC_STATE;
logic [1:0] code_scope_state_clean1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean1_comb     // test_array_cthread.cpp:235:5
    code_scope_state_clean1_func;
end
function void code_scope_state_clean1_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    integer j;
    k_next0 = k0;
    code_scope_state_clean1_PROC_STATE_next = code_scope_state_clean1_PROC_STATE;
    
    case (code_scope_state_clean1_PROC_STATE)
        0: begin
            dd_a[k_next0] = 1;
            code_scope_state_clean1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:245:17;
        end
        1: begin
            k_next0++;
            dd_a[k_next0] = 2;
            j = k_next0;
            code_scope_state_clean1_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:252:13;
        end
        2: begin
            dd_a[k_next0] = 1;
            code_scope_state_clean1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:245:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean1_ff
    if ( ~nrst ) begin
        k0 <= sig;
        code_scope_state_clean1_PROC_STATE <= 0;    // test_array_cthread.cpp:238:9;
    end
    else begin
        k0 <= k_next0;
        code_scope_state_clean1_PROC_STATE <= code_scope_state_clean1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean2 (test_array_cthread.cpp:257:5) 

// Thread-local variables
logic signed [31:0] k1;
logic signed [31:0] k_next1;
logic code_scope_state_clean2_PROC_STATE;
logic code_scope_state_clean2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean2_comb     // test_array_cthread.cpp:257:5
    code_scope_state_clean2_func;
end
function void code_scope_state_clean2_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    k_next1 = k1;
    code_scope_state_clean2_PROC_STATE_next = code_scope_state_clean2_PROC_STATE;
    
    case (code_scope_state_clean2_PROC_STATE)
        0: begin
            dd_a[k_next1] = 1;
            code_scope_state_clean2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:267:17;
        end
        1: begin
            k_next1++;
            dd_a[k_next1] = 2;
            dd_a[k_next1] = 1;
            code_scope_state_clean2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:267:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean2_ff
    if ( ~nrst ) begin
        k1 <= sig;
        code_scope_state_clean2_PROC_STATE <= 0;    // test_array_cthread.cpp:260:9;
    end
    else begin
        k1 <= k_next1;
        code_scope_state_clean2_PROC_STATE <= code_scope_state_clean2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr_multistate (test_array_cthread.cpp:277:5) 

// Thread-local variables
logic signed [31:0] k2;
logic signed [31:0] k_next2;
logic rec_loc_arr_multistate_PROC_STATE;
logic rec_loc_arr_multistate_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr_multistate_comb     // test_array_cthread.cpp:277:5
    rec_loc_arr_multistate_func;
end
function void rec_loc_arr_multistate_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    k_next2 = k2;
    rec_loc_arr_multistate_PROC_STATE_next = rec_loc_arr_multistate_PROC_STATE;
    
    case (rec_loc_arr_multistate_PROC_STATE)
        0: begin
            k_next2 = sig;
            dd_a[k_next2] = 2;
            rec_loc_arr_multistate_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:287:13;
        end
        1: begin
            dd_a[k_next2] = 3;
            k_next2 = sig;
            dd_a[k_next2] = 2;
            rec_loc_arr_multistate_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:287:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr_multistate_ff
    if ( ~nrst ) begin
        rec_loc_arr_multistate_PROC_STATE <= 0;    // test_array_cthread.cpp:280:9;
    end
    else begin
        k2 <= k_next2;
        rec_loc_arr_multistate_PROC_STATE <= rec_loc_arr_multistate_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr3 (test_array_cthread.cpp:294:5) 

// Thread-local variables
logic signed [1:0] dr_a[2];
logic signed [1:0] dr_a_next[2];
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic [3:0] drr_b[2][3];
logic [3:0] drr_b_next[2][3];
logic rec_loc_arr3_PROC_STATE;
logic rec_loc_arr3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr3_comb     // test_array_cthread.cpp:294:5
    rec_loc_arr3_func;
end
function void rec_loc_arr3_func;
    logic [3:0] dr_b[2];
    logic signed [1:0] drr_a[2][3];
    dr_a_next = dr_a;
    drr_b_next = drr_b;
    i_next = i0;
    rec_loc_arr3_PROC_STATE_next = rec_loc_arr3_PROC_STATE;
    
    case (rec_loc_arr3_PROC_STATE)
        0: begin
            i_next = sig;
            dr_a_next[i_next] = 2;
            drr_a[1][i_next + 1] = dr_a_next[1];
            rec_loc_arr3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:304:13;
        end
        1: begin
            i_next = drr_b_next[1][i_next];
            i_next = sig;
            dr_a_next[i_next] = 2;
            drr_a[1][i_next + 1] = dr_a_next[1];
            rec_loc_arr3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:304:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr3_ff
    if ( ~nrst ) begin
        rec_loc_arr3_PROC_STATE <= 0;    // test_array_cthread.cpp:296:9;
    end
    else begin
        dr_a <= dr_a_next;
        i0 <= i_next;
        drr_b <= drr_b_next;
        rec_loc_arr3_PROC_STATE <= rec_loc_arr3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr4 (test_array_cthread.cpp:311:5) 

// Thread-local variables
logic [3:0] err_b[2][3][4];
logic [3:0] err_b_next[2][3][4];
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic signed [31:0] j0;
logic signed [31:0] j_next;
logic rec_loc_arr4_PROC_STATE;
logic rec_loc_arr4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr4_comb     // test_array_cthread.cpp:311:5
    rec_loc_arr4_func;
end
function void rec_loc_arr4_func;
    logic signed [1:0] err_a[2][3][4];
    err_b_next = err_b;
    i_next0 = i1;
    j_next = j0;
    rec_loc_arr4_PROC_STATE_next = rec_loc_arr4_PROC_STATE;
    
    case (rec_loc_arr4_PROC_STATE)
        0: begin
            i_next0 = sig;
            j_next = sig;
            err_a[1][2][3] = j_next;
            err_b_next[1][j_next][1] = 42;
            err_b_next[i_next0][j_next + 1][2] = err_b_next[1][j_next][i_next0];
            rec_loc_arr4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:322:13;
        end
        1: begin
            i_next0 = err_b_next[i_next0][j_next + 1][2] + err_b_next[0][1][j_next];
            i_next0 = sig;
            j_next = sig;
            err_a[1][2][3] = j_next;
            err_b_next[1][j_next][1] = 42;
            err_b_next[i_next0][j_next + 1][2] = err_b_next[1][j_next][i_next0];
            rec_loc_arr4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:322:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr4_ff
    if ( ~nrst ) begin
        rec_loc_arr4_PROC_STATE <= 0;    // test_array_cthread.cpp:313:9;
    end
    else begin
        err_b <= err_b_next;
        i1 <= i_next0;
        j0 <= j_next;
        rec_loc_arr4_PROC_STATE <= rec_loc_arr4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr5 (test_array_cthread.cpp:330:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic [3:0] frr_b[2][3];
logic [3:0] frr_b_next[2][3];
logic rec_loc_arr5_PROC_STATE;
logic rec_loc_arr5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr5_comb     // test_array_cthread.cpp:330:5
    rec_loc_arr5_func;
end
function void rec_loc_arr5_func;
    logic signed [1:0] frr_a[2][3];
    integer j;
    frr_b_next = frr_b;
    i_next1 = i2;
    rec_loc_arr5_PROC_STATE_next = rec_loc_arr5_PROC_STATE;
    
    case (rec_loc_arr5_PROC_STATE)
        0: begin
            i_next1 = sig;
            rec_loc_arr5_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:337:13;
        end
        1: begin
            frr_b_next[i_next1][1] = 42;
            j = frr_b_next[1][1];
            i_next1 = sig;
            rec_loc_arr5_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:337:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr5_ff
    if ( ~nrst ) begin
        rec_loc_arr5_PROC_STATE <= 0;    // test_array_cthread.cpp:332:9;
    end
    else begin
        i2 <= i_next1;
        frr_b <= frr_b_next;
        rec_loc_arr5_PROC_STATE <= rec_loc_arr5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr6 (test_array_cthread.cpp:344:5) 

// Thread-local variables
logic signed [31:0] i3;
logic signed [31:0] i_next2;
logic [3:0] grr_b[2][3];
logic [3:0] grr_b_next[2][3];
logic rec_loc_arr6_PROC_STATE;
logic rec_loc_arr6_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr6_comb     // test_array_cthread.cpp:344:5
    rec_loc_arr6_func;
end
function void rec_loc_arr6_func;
    logic signed [1:0] grr_a[2][3];
    integer j;
    grr_b_next = grr_b;
    i_next2 = i3;
    rec_loc_arr6_PROC_STATE_next = rec_loc_arr6_PROC_STATE;
    
    case (rec_loc_arr6_PROC_STATE)
        0: begin
            i_next2 = sig;
            rec_loc_arr6_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:351:13;
        end
        1: begin
            grr_b_next[1][i_next2] = 42;
            j = grr_b_next[1][1];
            i_next2 = sig;
            rec_loc_arr6_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:351:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr6_ff
    if ( ~nrst ) begin
        rec_loc_arr6_PROC_STATE <= 0;    // test_array_cthread.cpp:346:9;
    end
    else begin
        i3 <= i_next2;
        grr_b <= grr_b_next;
        rec_loc_arr6_PROC_STATE <= rec_loc_arr6_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr7 (test_array_cthread.cpp:358:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next3;
logic [3:0] hrr_b[2][3];
logic [3:0] hrr_b_next[2][3];
logic rec_loc_arr7_PROC_STATE;
logic rec_loc_arr7_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr7_comb     // test_array_cthread.cpp:358:5
    rec_loc_arr7_func;
end
function void rec_loc_arr7_func;
    logic signed [1:0] hrr_a[2][3];
    integer j;
    hrr_b_next = hrr_b;
    i_next3 = i4;
    rec_loc_arr7_PROC_STATE_next = rec_loc_arr7_PROC_STATE;
    
    case (rec_loc_arr7_PROC_STATE)
        0: begin
            i_next3 = sig;
            rec_loc_arr7_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:365:13;
        end
        1: begin
            hrr_b_next[1][1] = 42;
            j = hrr_b_next[i_next3][1];
            i_next3 = sig;
            rec_loc_arr7_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:365:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr7_ff
    if ( ~nrst ) begin
        rec_loc_arr7_PROC_STATE <= 0;    // test_array_cthread.cpp:360:9;
    end
    else begin
        i4 <= i_next3;
        hrr_b <= hrr_b_next;
        rec_loc_arr7_PROC_STATE <= rec_loc_arr7_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr8 (test_array_cthread.cpp:372:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next4;
logic [3:0] jrr_b[2][3];
logic [3:0] jrr_b_next[2][3];
logic rec_loc_arr8_PROC_STATE;
logic rec_loc_arr8_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr8_comb     // test_array_cthread.cpp:372:5
    rec_loc_arr8_func;
end
function void rec_loc_arr8_func;
    logic signed [1:0] jrr_a[2][3];
    integer j;
    i_next4 = i5;
    jrr_b_next = jrr_b;
    rec_loc_arr8_PROC_STATE_next = rec_loc_arr8_PROC_STATE;
    
    case (rec_loc_arr8_PROC_STATE)
        0: begin
            i_next4 = sig;
            rec_loc_arr8_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:379:13;
        end
        1: begin
            jrr_b_next[1][1] = 42;
            j = jrr_b_next[1][i_next4];
            i_next4 = sig;
            rec_loc_arr8_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:379:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr8_ff
    if ( ~nrst ) begin
        rec_loc_arr8_PROC_STATE <= 0;    // test_array_cthread.cpp:374:9;
    end
    else begin
        i5 <= i_next4;
        jrr_b <= jrr_b_next;
        rec_loc_arr8_PROC_STATE <= rec_loc_arr8_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr9 (test_array_cthread.cpp:386:5) 

// Thread-local variables
logic signed [31:0] i6;
logic signed [31:0] i_next5;
logic [3:0] irr_b[2][3];
logic [3:0] irr_b_next[2][3];
logic rec_loc_arr9_PROC_STATE;
logic rec_loc_arr9_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr9_comb     // test_array_cthread.cpp:386:5
    rec_loc_arr9_func;
end
function void rec_loc_arr9_func;
    logic signed [1:0] irr_a[2][3];
    integer j;
    i_next5 = i6;
    irr_b_next = irr_b;
    rec_loc_arr9_PROC_STATE_next = rec_loc_arr9_PROC_STATE;
    
    case (rec_loc_arr9_PROC_STATE)
        0: begin
            i_next5 = sig;
            rec_loc_arr9_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:393:13;
        end
        1: begin
            irr_b_next[i_next5][i_next5] = 42;
            j = irr_b_next[i_next5][i_next5];
            i_next5 = sig;
            rec_loc_arr9_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:393:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr9_ff
    if ( ~nrst ) begin
        rec_loc_arr9_PROC_STATE <= 0;    // test_array_cthread.cpp:388:9;
    end
    else begin
        i6 <= i_next5;
        irr_b <= irr_b_next;
        rec_loc_arr9_PROC_STATE <= rec_loc_arr9_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr10 (test_array_cthread.cpp:400:5) 

// Thread-local variables
logic rec_loc_arr10_PROC_STATE;
logic rec_loc_arr10_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr10_comb     // test_array_cthread.cpp:400:5
    rec_loc_arr10_func;
end
function void rec_loc_arr10_func;
    logic signed [1:0] krr_a[2][3];
    logic [3:0] krr_b[2][3];
    integer i;
    integer j;
    rec_loc_arr10_PROC_STATE_next = rec_loc_arr10_PROC_STATE;
    
    case (rec_loc_arr10_PROC_STATE)
        0: begin
            i = sig;
            rec_loc_arr10_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:407:13;
        end
        1: begin
            krr_b[1][2] = 42;
            j = krr_b[1][2];
            i = sig;
            rec_loc_arr10_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:407:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr10_ff
    if ( ~nrst ) begin
        rec_loc_arr10_PROC_STATE <= 0;    // test_array_cthread.cpp:402:9;
    end
    else begin
        rec_loc_arr10_PROC_STATE <= rec_loc_arr10_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_field_assign (test_array_cthread.cpp:433:5) 

// Thread-local variables
logic [3:0] pr_b[3];
logic [3:0] pr_b_next[3];
logic signed [1:0] rr_a[3];
logic signed [1:0] rr_a_next[3];

// Next-state combinational logic
always_comb begin : rec_arr_elem_field_assign_comb     // test_array_cthread.cpp:433:5
    rec_arr_elem_field_assign_func;
end
function void rec_arr_elem_field_assign_func;
    logic signed [1:0] pr_a[3];
    logic [3:0] rr_b[3];
    pr_b_next = pr_b;
    rr_a_next = rr_a;
    for (integer i = 0; i < 2; i++)
    begin
        rr_b[i] = pr_b_next[i + 1];
        pr_a[i + 1] = rr_a_next[i];
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_field_assign_ff
    if ( ~nrst ) begin
    end
    else begin
        pr_b <= pr_b_next;
        rr_a <= rr_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val1 (test_array_cthread.cpp:501:5) 

// Thread-local variables
logic signed [1:0] par_a;
logic signed [1:0] par_a_next;
logic [3:0] par_b;
logic [3:0] par_b_next;
logic [1:0] rec_arr_elem_const_val1_PROC_STATE;
logic [1:0] rec_arr_elem_const_val1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val1_comb     // test_array_cthread.cpp:501:5
    rec_arr_elem_const_val1_func;
end
function void rec_arr_elem_const_val1_func;
    logic signed [1:0] sr_a;
    logic [3:0] sr_b;
    integer i;
    par_a_next = par_a;
    par_b_next = par_b;
    rec_arr_elem_const_val1_PROC_STATE_next = rec_arr_elem_const_val1_PROC_STATE;
    
    case (rec_arr_elem_const_val1_PROC_STATE)
        0: begin
            sr_a = 0;
            sr_b = 0;
            sr_b = sig;
            par_a_next = sr_a; par_b_next = sr_b;
            // Call ff1() begin
            rec_arr_elem_const_val1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
        1: begin
            // Call ff1() begin
            i = par_a_next + par_b_next;
            // Call ff1() end
            rec_arr_elem_const_val1_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:509:13;
        end
        2: begin
            sr_a = 0;
            sr_b = 0;
            sr_b = sig;
            par_a_next = sr_a; par_b_next = sr_b;
            // Call ff1() begin
            rec_arr_elem_const_val1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val1_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val1_PROC_STATE <= 0;    // test_array_cthread.cpp:503:9;
    end
    else begin
        par_a <= par_a_next;
        par_b <= par_b_next;
        rec_arr_elem_const_val1_PROC_STATE <= rec_arr_elem_const_val1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val2 (test_array_cthread.cpp:513:5) 

// Thread-local variables
logic signed [1:0] par_a0;
logic signed [1:0] par_a_next0;
logic [3:0] par_b0;
logic [3:0] par_b_next0;
logic signed [1:0] sr_a0;
logic signed [1:0] sr_a_next;
logic [3:0] sr_b0;
logic [3:0] sr_b_next;
logic [1:0] rec_arr_elem_const_val2_PROC_STATE;
logic [1:0] rec_arr_elem_const_val2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val2_comb     // test_array_cthread.cpp:513:5
    rec_arr_elem_const_val2_func;
end
function void rec_arr_elem_const_val2_func;
    integer i;
    par_a_next0 = par_a0;
    par_b_next0 = par_b0;
    sr_a_next = sr_a0;
    sr_b_next = sr_b0;
    rec_arr_elem_const_val2_PROC_STATE_next = rec_arr_elem_const_val2_PROC_STATE;
    
    case (rec_arr_elem_const_val2_PROC_STATE)
        0: begin
            sr_a_next = 0;
            sr_b_next = 0;
            rec_arr_elem_const_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:518:13;
        end
        1: begin
            par_a_next0 = sr_a_next; par_b_next0 = sr_b_next;
            // Call ff1() begin
            rec_arr_elem_const_val2_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
        2: begin
            // Call ff1() begin
            i = par_a_next0 + par_b_next0;
            // Call ff1() end
            sr_a_next = 0;
            sr_b_next = 0;
            rec_arr_elem_const_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:518:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val2_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val2_PROC_STATE <= 0;    // test_array_cthread.cpp:515:9;
    end
    else begin
        par_a0 <= par_a_next0;
        par_b0 <= par_b_next0;
        sr_a0 <= sr_a_next;
        sr_b0 <= sr_b_next;
        rec_arr_elem_const_val2_PROC_STATE <= rec_arr_elem_const_val2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val3 (test_array_cthread.cpp:524:5) 

// Thread-local variables
logic signed [1:0] crra_a[3];
logic signed [1:0] crra_a_next[3];
logic [3:0] crra_b[3];
logic [3:0] crra_b_next[3];
logic signed [1:0] par_a1;
logic signed [1:0] par_a_next1;
logic [3:0] par_b1;
logic [3:0] par_b_next1;
logic [1:0] rec_arr_elem_const_val3_PROC_STATE;
logic [1:0] rec_arr_elem_const_val3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val3_comb     // test_array_cthread.cpp:524:5
    rec_arr_elem_const_val3_func;
end
function void rec_arr_elem_const_val3_func;
    integer i;
    crra_a_next = crra_a;
    crra_b_next = crra_b;
    par_a_next1 = par_a1;
    par_b_next1 = par_b1;
    rec_arr_elem_const_val3_PROC_STATE_next = rec_arr_elem_const_val3_PROC_STATE;
    
    case (rec_arr_elem_const_val3_PROC_STATE)
        0: begin
            par_a_next1 = crra_a_next[1]; par_b_next1 = crra_b_next[1];
            // Call ff1() begin
            rec_arr_elem_const_val3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
        1: begin
            // Call ff1() begin
            i = par_a_next1 + par_b_next1;
            // Call ff1() end
            rec_arr_elem_const_val3_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:530:13;
        end
        2: begin
            par_a_next1 = crra_a_next[1]; par_b_next1 = crra_b_next[1];
            // Call ff1() begin
            rec_arr_elem_const_val3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val3_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val3_PROC_STATE <= 0;    // test_array_cthread.cpp:527:9;
    end
    else begin
        crra_a <= crra_a_next;
        crra_b <= crra_b_next;
        par_a1 <= par_a_next1;
        par_b1 <= par_b_next1;
        rec_arr_elem_const_val3_PROC_STATE <= rec_arr_elem_const_val3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val4 (test_array_cthread.cpp:534:5) 

// Thread-local variables
logic signed [1:0] par_a2;
logic signed [1:0] par_a_next2;
logic [3:0] par_b2;
logic [3:0] par_b_next2;
logic signed [1:0] crrb_a[3];
logic signed [1:0] crrb_a_next[3];
logic [3:0] crrb_b[3];
logic [3:0] crrb_b_next[3];
logic [1:0] rec_arr_elem_const_val4_PROC_STATE;
logic [1:0] rec_arr_elem_const_val4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val4_comb     // test_array_cthread.cpp:534:5
    rec_arr_elem_const_val4_func;
end
function void rec_arr_elem_const_val4_func;
    integer i;
    integer i_1;
    crrb_a_next = crrb_a;
    crrb_b_next = crrb_b;
    par_a_next2 = par_a2;
    par_b_next2 = par_b2;
    rec_arr_elem_const_val4_PROC_STATE_next = rec_arr_elem_const_val4_PROC_STATE;
    
    case (rec_arr_elem_const_val4_PROC_STATE)
        0: begin
            rec_arr_elem_const_val4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:539:13;
        end
        1: begin
            i = sig;
            par_a_next2 = crrb_a_next[i]; par_b_next2 = crrb_b_next[i];
            // Call ff1() begin
            rec_arr_elem_const_val4_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:497:9;
            // Call ff1() end
        end
        2: begin
            // Call ff1() begin
            i_1 = par_a_next2 + par_b_next2;
            // Call ff1() end
            rec_arr_elem_const_val4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:539:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val4_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val4_PROC_STATE <= 0;    // test_array_cthread.cpp:537:9;
    end
    else begin
        par_a2 <= par_a_next2;
        par_b2 <= par_b_next2;
        crrb_a <= crrb_a_next;
        crrb_b <= crrb_b_next;
        rec_arr_elem_const_val4_PROC_STATE <= rec_arr_elem_const_val4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val (test_array_cthread.cpp:456:5) 

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val_comb     // test_array_cthread.cpp:456:5
    rec_arr_elem_func_param_val_func;
end
function void rec_arr_elem_func_param_val_func;
    logic signed [1:0] sr_a;
    logic [3:0] sr_b;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    sr_a = 0;
    sr_b = 0;
    par_a_1 = sr_a; par_b_1 = sr_b;
    // Call f1() begin
    i = par_b_1;
    // Call f1() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val_ff
    if ( ~nrst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val2 (test_array_cthread.cpp:468:5) 

// Thread-local variables
logic signed [1:0] tr_a[3];
logic signed [1:0] tr_a_next[3];
logic [3:0] tr_b[3];
logic [3:0] tr_b_next[3];

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val2_comb     // test_array_cthread.cpp:468:5
    rec_arr_elem_func_param_val2_func;
end
function void rec_arr_elem_func_param_val2_func;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    tr_a_next = tr_a;
    tr_b_next = tr_b;
    par_a_1 = tr_a_next[1]; par_b_1 = tr_b_next[1];
    // Call f1() begin
    i = par_b_1;
    // Call f1() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val2_ff
    if ( ~nrst ) begin
    end
    else begin
        tr_a <= tr_a_next;
        tr_b <= tr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val3 (test_array_cthread.cpp:481:5) 

// Thread-local variables
logic signed [31:0] i7;
logic signed [31:0] i_next6;
logic signed [1:0] tr_a0[3];
logic signed [1:0] tr_a_next0[3];
logic [3:0] tr_b0[3];
logic [3:0] tr_b_next0[3];

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val3_comb     // test_array_cthread.cpp:481:5
    rec_arr_elem_func_param_val3_func;
end
function void rec_arr_elem_func_param_val3_func;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    i_next6 = i7;
    tr_a_next0 = tr_a0;
    tr_b_next0 = tr_b0;
    par_a_1 = tr_a_next0[i_next6]; par_b_1 = tr_b_next0[i_next6];
    // Call f1() begin
    i = par_b_1;
    // Call f1() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val3_ff
    if ( ~nrst ) begin
        i7 <= sig;
    end
    else begin
        i7 <= i_next6;
        tr_a0 <= tr_a_next0;
        tr_b0 <= tr_b_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref (test_array_cthread.cpp:551:5) 

// Thread-local variables
logic [3:0] vr_b[3];
logic [3:0] vr_b_next[3];
logic rec_arr_elem_func_param_ref_PROC_STATE;
logic rec_arr_elem_func_param_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref_comb     // test_array_cthread.cpp:551:5
    rec_arr_elem_func_param_ref_func;
end
function void rec_arr_elem_func_param_ref_func;
    logic signed [1:0] vr_a[3];
    integer k_1;
    integer i;
    vr_b_next = vr_b;
    rec_arr_elem_func_param_ref_PROC_STATE_next = rec_arr_elem_func_param_ref_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref_PROC_STATE)
        0: begin
            // Call f2() begin
            k_1 = vr_b_next[1];
            // Call f2() end
            rec_arr_elem_func_param_ref_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:557:13;
        end
        1: begin
            i = sig;
            // Call f2() begin
            k_1 = vr_b_next[i];
            // Call f2() end
            // Call f2() begin
            k_1 = vr_b_next[1];
            // Call f2() end
            rec_arr_elem_func_param_ref_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:557:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref_ff
    if ( ~nrst ) begin
        rec_arr_elem_func_param_ref_PROC_STATE <= 0;    // test_array_cthread.cpp:553:9;
    end
    else begin
        vr_b <= vr_b_next;
        rec_arr_elem_func_param_ref_PROC_STATE <= rec_arr_elem_func_param_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref2 (test_array_cthread.cpp:593:5) 

// Thread-local variables
logic signed [31:0] i8;
logic signed [31:0] i_next7;
logic [3:0] wrr_b[2];
logic [3:0] wrr_b_next[2];
logic [3:0] wr_b[3];
logic [3:0] wr_b_next[3];
logic rec_arr_elem_func_param_ref2_PROC_STATE;
logic rec_arr_elem_func_param_ref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref2_comb     // test_array_cthread.cpp:593:5
    rec_arr_elem_func_param_ref2_func;
end
function void rec_arr_elem_func_param_ref2_func;
    logic signed [1:0] wrr_a[2];
    logic signed [1:0] wr_a[3];
    integer k_1;
    logic signed [1:0] w_a;
    logic [3:0] w_b;
    i_next7 = i8;
    wr_b_next = wr_b;
    wrr_b_next = wrr_b;
    rec_arr_elem_func_param_ref2_PROC_STATE_next = rec_arr_elem_func_param_ref2_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref2_PROC_STATE)
        0: begin
            // Call f2_two() begin
            k_1 = wr_b_next[1] + wrr_b_next[i_next7];
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next7] + wr_b_next[1];
            // Call f2_two() end
            rec_arr_elem_func_param_ref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:604:13;
        end
        1: begin
            w_a = 0;
            w_b = 0;
            // Call f2_two() begin
            k_1 = w_b + wrr_b_next[0];
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next7 - 1] + w_b;
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[1] + wrr_b_next[i_next7];
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next7] + wr_b_next[1];
            // Call f2_two() end
            rec_arr_elem_func_param_ref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:604:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref2_ff
    if ( ~nrst ) begin
        logic signed [1:0] wrr_a[2];
        i8 <= sig;
        rec_arr_elem_func_param_ref2_PROC_STATE <= 0;    // test_array_cthread.cpp:597:9;
    end
    else begin
        i8 <= i_next7;
        wrr_b <= wrr_b_next;
        wr_b <= wr_b_next;
        rec_arr_elem_func_param_ref2_PROC_STATE <= rec_arr_elem_func_param_ref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref3 (test_array_cthread.cpp:616:5) 

// Thread-local variables
logic signed [31:0] i9;
logic signed [31:0] i_next8;
logic rec_arr_elem_func_param_ref3_PROC_STATE;
logic rec_arr_elem_func_param_ref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref3_comb     // test_array_cthread.cpp:616:5
    rec_arr_elem_func_param_ref3_func;
end
function void rec_arr_elem_func_param_ref3_func;
    logic signed [1:0] vr_a[3];
    logic [3:0] vr_b_1[3];
    i_next8 = i9;
    rec_arr_elem_func_param_ref3_PROC_STATE_next = rec_arr_elem_func_param_ref3_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref3_PROC_STATE)
        0: begin
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[i_next8 + 1] = 1;
            // Call f3() end
            rec_arr_elem_func_param_ref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:626:13;
        end
        1: begin
            // Call f3() begin
            vr_b_1[i_next8 - 1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[i_next8 + 1] = 1;
            // Call f3() end
            rec_arr_elem_func_param_ref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:626:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref3_ff
    if ( ~nrst ) begin
        i9 <= sig;
        rec_arr_elem_func_param_ref3_PROC_STATE <= 0;    // test_array_cthread.cpp:619:9;
    end
    else begin
        i9 <= i_next8;
        rec_arr_elem_func_param_ref3_PROC_STATE <= rec_arr_elem_func_param_ref3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_func_param_val (test_array_cthread.cpp:701:5) 

// Thread-local variables
logic [3:0] ar_b1[2];
logic [3:0] ar_b_next1[2];
logic signed [1:0] ar_a0[2];
logic signed [1:0] ar_a_next[2];

// Next-state combinational logic
always_comb begin : rec_arr_func_param_val_comb     // test_array_cthread.cpp:701:5
    rec_arr_func_param_val_func;
end
function void rec_arr_func_param_val_func;
    integer indx;
    logic c;
    ar_a_next = ar_a0;
    ar_b_next1 = ar_b1;
    // Call f5() begin
    indx = ar_b_next1[1];
    c = ar_a_next[indx] == 2;
    // Call f5() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_func_param_val_ff
    if ( ~nrst ) begin
    end
    else begin
        ar_b1 <= ar_b_next1;
        ar_a0 <= ar_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_func_param_val2 (test_array_cthread.cpp:711:5) 

// Thread-local variables
logic [3:0] ar_b2[2];
logic [3:0] ar_b_next2[2];
logic signed [1:0] ar_a1[2];
logic signed [1:0] ar_a_next0[2];
logic rec_arr_func_param_val2_PROC_STATE;
logic rec_arr_func_param_val2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_func_param_val2_comb     // test_array_cthread.cpp:711:5
    rec_arr_func_param_val2_func;
end
function void rec_arr_func_param_val2_func;
    integer i;
    integer indx;
    logic c;
    ar_a_next0 = ar_a1;
    ar_b_next2 = ar_b2;
    rec_arr_func_param_val2_PROC_STATE_next = rec_arr_func_param_val2_PROC_STATE;
    
    case (rec_arr_func_param_val2_PROC_STATE)
        0: begin
            i = sig;
            ar_a_next0[i] = 0;
            ar_b_next2[i] = 1;
            rec_arr_func_param_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:719:13;
        end
        1: begin
            // Call f5() begin
            indx = ar_b_next2[1];
            c = ar_a_next0[indx] == 2;
            // Call f5() end
            i = sig;
            ar_a_next0[i] = 0;
            ar_b_next2[i] = 1;
            rec_arr_func_param_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:719:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_func_param_val2_ff
    if ( ~nrst ) begin
        rec_arr_func_param_val2_PROC_STATE <= 0;    // test_array_cthread.cpp:713:9;
    end
    else begin
        ar_b2 <= ar_b_next2;
        ar_a1 <= ar_a_next0;
        rec_arr_func_param_val2_PROC_STATE <= rec_arr_func_param_val2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref1 (test_array_cthread.cpp:639:5) 

// Thread-local variables
logic signed [1:0] cvr_a[3];
logic signed [1:0] cvr_a_next[3];
logic [3:0] cvr_b[3];
logic [3:0] cvr_b_next[3];
logic signed [1:0] cwr_a[3];
logic signed [1:0] cwr_a_next[3];
logic [3:0] cwr_b[3];
logic [3:0] cwr_b_next[3];
logic [1:0] rec_arr_elem_func_param_cref1_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref1_comb     // test_array_cthread.cpp:639:5
    rec_arr_elem_func_param_cref1_func;
end
function void rec_arr_elem_func_param_cref1_func;
    integer indx;
    integer res;
    cvr_a_next = cvr_a;
    cvr_b_next = cvr_b;
    cwr_a_next = cwr_a;
    cwr_b_next = cwr_b;
    rec_arr_elem_func_param_cref1_PROC_STATE_next = rec_arr_elem_func_param_cref1_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref1_PROC_STATE)
        0: begin
            // Call cref_sum() begin
            res = cvr_a_next[1] + cvr_b_next[1];
            // Call cref_sum() end
            rec_arr_elem_func_param_cref1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:647:13;
        end
        1: begin
            indx = sig;
            // Call cref_sum() begin
            res = cwr_a_next[indx] + cwr_b_next[indx];
            // Call cref_sum() end
            rec_arr_elem_func_param_cref1_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:652:13;
        end
        2: begin
            // Call cref_sum() begin
            res = cvr_a_next[1] + cvr_b_next[1];
            // Call cref_sum() end
            rec_arr_elem_func_param_cref1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:647:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref1_ff
    if ( ~nrst ) begin
        integer indx;
        indx = 0;
        rec_arr_elem_func_param_cref1_PROC_STATE <= 0;    // test_array_cthread.cpp:642:9;
    end
    else begin
        cvr_a <= cvr_a_next;
        cvr_b <= cvr_b_next;
        cwr_a <= cwr_a_next;
        cwr_b <= cwr_b_next;
        rec_arr_elem_func_param_cref1_PROC_STATE <= rec_arr_elem_func_param_cref1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref2 (test_array_cthread.cpp:664:5) 

// Thread-local variables
logic signed [1:0] cvrr_a[3];
logic signed [1:0] cvrr_a_next[3];
logic signed [31:0] res0;
logic signed [31:0] res_next;
logic [3:0] cvrr_b[3];
logic [3:0] cvrr_b_next[3];
logic [1:0] rec_arr_elem_func_param_cref2_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref2_comb     // test_array_cthread.cpp:664:5
    rec_arr_elem_func_param_cref2_func;
end
function void rec_arr_elem_func_param_cref2_func;
    integer TMP_0;
    integer res;
    integer TMP_2;
    cvrr_a_next = cvrr_a;
    cvrr_b_next = cvrr_b;
    res_next = res0;
    rec_arr_elem_func_param_cref2_PROC_STATE_next = rec_arr_elem_func_param_cref2_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref2_PROC_STATE)
        0: begin
            if (|sig)
            begin
                // Call cref_wait() begin
                res_next = cvrr_a_next[2];
                rec_arr_elem_func_param_cref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:659:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref2_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:674:13;
        end
        1: begin
            // Call cref_wait() begin
            res_next = res_next + cvrr_b_next[2];
            TMP_0 = res_next;
            // Call cref_wait() end
            res = TMP_0;
            rec_arr_elem_func_param_cref2_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:674:13;
        end
        2: begin
            if (|sig)
            begin
                // Call cref_wait() begin
                res_next = cvrr_a_next[2];
                rec_arr_elem_func_param_cref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:659:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref2_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:674:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref2_ff
    if ( ~nrst ) begin
        integer indx;
        indx = 0;
        rec_arr_elem_func_param_cref2_PROC_STATE <= 0;    // test_array_cthread.cpp:667:9;
    end
    else begin
        cvrr_a <= cvrr_a_next;
        res0 <= res_next;
        cvrr_b <= cvrr_b_next;
        rec_arr_elem_func_param_cref2_PROC_STATE <= rec_arr_elem_func_param_cref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref3 (test_array_cthread.cpp:678:5) 

// Thread-local variables
logic signed [1:0] cwrr_a[3];
logic signed [1:0] cwrr_a_next[3];
logic signed [31:0] res1;
logic signed [31:0] res_next0;
logic [3:0] cwrr_b[3];
logic [3:0] cwrr_b_next[3];
logic [1:0] rec_arr_elem_func_param_cref3_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref3_comb     // test_array_cthread.cpp:678:5
    rec_arr_elem_func_param_cref3_func;
end
function void rec_arr_elem_func_param_cref3_func;
    integer indx;
    integer TMP_0;
    integer TMP_1;
    cwrr_a_next = cwrr_a;
    cwrr_b_next = cwrr_b;
    res_next0 = res1;
    rec_arr_elem_func_param_cref3_PROC_STATE_next = rec_arr_elem_func_param_cref3_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref3_PROC_STATE)
        0: begin
            if (sig < 3)
            begin
                indx = sig;
                // Call cref_wait() begin
                res_next0 = cwrr_a_next[indx];
                rec_arr_elem_func_param_cref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:659:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref3_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:689:13;
        end
        1: begin
            // Call cref_wait() begin
            res_next0 = res_next0 + cwrr_b_next[indx];
            TMP_0 = res_next0;
            // Call cref_wait() end
            rec_arr_elem_func_param_cref3_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:689:13;
        end
        2: begin
            if (sig < 3)
            begin
                indx = sig;
                // Call cref_wait() begin
                res_next0 = cwrr_a_next[indx];
                rec_arr_elem_func_param_cref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:659:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref3_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:689:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref3_ff
    if ( ~nrst ) begin
        integer indx;
        indx = 0;
        rec_arr_elem_func_param_cref3_PROC_STATE <= 0;    // test_array_cthread.cpp:681:9;
    end
    else begin
        cwrr_a <= cwrr_a_next;
        res1 <= res_next0;
        cwrr_b <= cwrr_b_next;
        rec_arr_elem_func_param_cref3_PROC_STATE <= rec_arr_elem_func_param_cref3_PROC_STATE_next;
    end
end

endmodule



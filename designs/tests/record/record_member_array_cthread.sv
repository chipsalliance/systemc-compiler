//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.8
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rst;
logic [3:0] sig;

//------------------------------------------------------------------------------
// Clocked THREAD: mult_array_decl (test_member_array_cthread.cpp:110:5) 

// Thread-local variables
logic qarr_a[5][4][3];
logic qarr_a_next[5][4][3];
logic [3:0] parr_b[4][3][2];
logic [3:0] parr_b_next[4][3][2];

// Next-state combinational logic
always_comb begin : mult_array_decl_comb     // test_member_array_cthread.cpp:110:5
    mult_array_decl_func;
end
function void mult_array_decl_func;
    logic aa;
    logic [3:0] bb;
    parr_b_next = parr_b;
    qarr_a_next = qarr_a;
    aa = qarr_a_next[3][2][1];
    bb = parr_b_next[2][1][0];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : mult_array_decl_ff
    if ( rst ) begin
        logic [3:0] qarr_b[5][4][3];
        qarr_b[4][3][2] = 0;
        parr_b[3][2][1] <= 0;
    end
    else begin
        qarr_a <= qarr_a_next;
        parr_b <= parr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl1 (test_member_array_cthread.cpp:128:5) 

// Next-state combinational logic
always_comb begin : loc_array_decl1_comb     // test_member_array_cthread.cpp:128:5
    loc_array_decl1_func;
end
function void loc_array_decl1_func;
    logic xarr1_a[2][3];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl1_ff
    if ( rst ) begin
        logic xarr1_a[2][3];
        logic [3:0] xarr1_b[2][3];
        xarr1_b[1][2] = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl2 (test_member_array_cthread.cpp:140:5) 

// Next-state combinational logic
always_comb begin : loc_array_decl2_comb     // test_member_array_cthread.cpp:140:5
    loc_array_decl2_func;
end
function void loc_array_decl2_func;
    logic xarr2_a[2][3];
    logic [3:0] xarr2_b[2][3];
    xarr2_b[1][2] = 0;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl2_ff
    if ( rst ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl3 (test_member_array_cthread.cpp:152:5) 

// Thread-local variables
logic [3:0] xarr3_b[2][3];
logic [3:0] xarr3_b_next[2][3];
logic loc_array_decl3_PROC_STATE;
logic loc_array_decl3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl3_comb     // test_member_array_cthread.cpp:152:5
    loc_array_decl3_func;
end
function void loc_array_decl3_func;
    logic xarr3_a[2][3];
    logic [3:0] l;
    xarr3_b_next = xarr3_b;
    loc_array_decl3_PROC_STATE_next = loc_array_decl3_PROC_STATE;
    
    case (loc_array_decl3_PROC_STATE)
        0: begin
            xarr3_b_next[1][2] = 0;
            loc_array_decl3_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:160:13;
        end
        1: begin
            l = xarr3_b_next[1][1];
            xarr3_b_next[1][2] = 0;
            loc_array_decl3_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:160:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl3_ff
    if ( rst ) begin
        loc_array_decl3_PROC_STATE <= 0;    // test_member_array_cthread.cpp:154:9;
    end
    else begin
        xarr3_b <= xarr3_b_next;
        loc_array_decl3_PROC_STATE <= loc_array_decl3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl4 (test_member_array_cthread.cpp:165:5) 

// Thread-local variables
logic [3:0] xarr4_b[2][3];
logic [3:0] xarr4_b_next[2][3];
logic loc_array_decl4_PROC_STATE;
logic loc_array_decl4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl4_comb     // test_member_array_cthread.cpp:165:5
    loc_array_decl4_func;
end
function void loc_array_decl4_func;
    logic xarr4_a[2][3];
    logic [3:0] l;
    xarr4_b_next = xarr4_b;
    loc_array_decl4_PROC_STATE_next = loc_array_decl4_PROC_STATE;
    
    case (loc_array_decl4_PROC_STATE)
        0: begin
            xarr4_b_next[1][2] = 0;
            loc_array_decl4_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:173:13;
        end
        1: begin
            l = xarr4_b_next[1][2];
            xarr4_b_next[1][2] = 0;
            loc_array_decl4_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:173:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl4_ff
    if ( rst ) begin
        loc_array_decl4_PROC_STATE <= 0;    // test_member_array_cthread.cpp:167:9;
    end
    else begin
        xarr4_b <= xarr4_b_next;
        loc_array_decl4_PROC_STATE <= loc_array_decl4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl5 (test_member_array_cthread.cpp:180:5) 

// Thread-local variables
logic [3:0] xlarr5_b[2][3];
logic [3:0] xlarr5_b_next[2][3];
logic [3:0] xarr5_b[2][3];
logic [3:0] xarr5_b_next[2][3];
logic loc_array_decl5_PROC_STATE;
logic loc_array_decl5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_decl5_comb     // test_member_array_cthread.cpp:180:5
    loc_array_decl5_func;
end
function void loc_array_decl5_func;
    integer j;
    logic xlarr5_a[2][3];
    logic [63:0] l;
    xarr5_b_next = xarr5_b;
    xlarr5_b_next = xlarr5_b;
    loc_array_decl5_PROC_STATE_next = loc_array_decl5_PROC_STATE;
    
    case (loc_array_decl5_PROC_STATE)
        0: begin
            j = sig;
            xarr5_b_next[1][j] = 0;
            xlarr5_b_next[1][j] = 0;
            loc_array_decl5_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:192:13;
        end
        1: begin
            l = xarr5_b_next[1][2] + xlarr5_b_next[1][2];
            j = sig;
            xarr5_b_next[1][j] = 0;
            xlarr5_b_next[1][j] = 0;
            loc_array_decl5_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:192:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl5_ff
    if ( rst ) begin
        loc_array_decl5_PROC_STATE <= 0;    // test_member_array_cthread.cpp:182:9;
    end
    else begin
        xlarr5_b <= xlarr5_b_next;
        xarr5_b <= xarr5_b_next;
        loc_array_decl5_PROC_STATE <= loc_array_decl5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_decl6 (test_member_array_cthread.cpp:198:5) 

// Thread-local variables
logic [3:0] xarr6_b[2][3];
logic [3:0] xarr6_b_next[2][3];

// Next-state combinational logic
always_comb begin : loc_array_decl6_comb     // test_member_array_cthread.cpp:198:5
    loc_array_decl6_func;
end
function void loc_array_decl6_func;
    integer j;
    logic xarr6_a[2][3];
    logic [3:0] l;
    xarr6_b_next = xarr6_b;
    j = sig;
    xarr6_b_next[j][2] = 0;
    l = xarr6_b_next[1][2];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_decl6_ff
    if ( rst ) begin
    end
    else begin
        xarr6_b <= xarr6_b_next;
    end
end

//------------------------------------------------------------------------------
// Method process: loc_array_decl6_meth (test_member_array_cthread.cpp:214:5) 

always_comb 
begin : loc_array_decl6_meth     // test_member_array_cthread.cpp:214:5
    integer j;
    logic xarr6_a[2][3];
    logic [3:0] xarr6_b_1[2][3];
    logic [3:0] l;
    j = sig;
    xarr6_b_1[j][2] = 0;
    l = xarr6_b_1[1][2];
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_copy (test_member_array_cthread.cpp:234:5) 

// Thread-local variables
logic [3:0] par_b[3];
logic [3:0] par_b_next[3];
logic [1:0] loc_array_copy_PROC_STATE;
logic [1:0] loc_array_copy_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : loc_array_copy_comb     // test_member_array_cthread.cpp:234:5
    loc_array_copy_func;
end
function void loc_array_copy_func;
    logic xlarr_a[3];
    logic [3:0] xlarr_b[3];
    logic par_a[3];
    integer j;
    logic [3:0] l;
    par_b_next = par_b;
    loc_array_copy_PROC_STATE_next = loc_array_copy_PROC_STATE;
    
    case (loc_array_copy_PROC_STATE)
        0: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_a = xlarr_a; par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            j = sig;
            par_b_next[j] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:229:9;
            // Call rec_param_copy() end
        end
        1: begin
            // Call rec_param_copy() begin
            l = par_b_next[1];
            // Call rec_param_copy() end
            loc_array_copy_PROC_STATE_next = 2; return;    // test_member_array_cthread.cpp:243:13;
        end
        2: begin
            xlarr_b[0] = 0; xlarr_b[1] = 0; xlarr_b[2] = 0;
            par_a = xlarr_a; par_b_next = xlarr_b;
            // Call rec_param_copy() begin
            j = sig;
            par_b_next[j] = 1;
            loc_array_copy_PROC_STATE_next = 1; return;    // test_member_array_cthread.cpp:229:9;
            // Call rec_param_copy() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_copy_ff
    if ( rst ) begin
        loc_array_copy_PROC_STATE <= 0;    // test_member_array_cthread.cpp:236:9;
    end
    else begin
        par_b <= par_b_next;
        loc_array_copy_PROC_STATE <= loc_array_copy_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_init (test_member_array_cthread.cpp:272:5) 

// Next-state combinational logic
always_comb begin : loc_array_init_comb     // test_member_array_cthread.cpp:272:5
    loc_array_init_func;
end
function void loc_array_init_func;
    logic xarr_a[2][3];
    logic [3:0] xarr_b[2][3];
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_init_ff
    if ( rst ) begin
        logic x_a[3];
        logic [3:0] x_b[3];
        logic xarr_a[2][3];
        logic [3:0] xarr_b[2][3];
        x_b[0] = 0; x_b[1] = 0; x_b[2] = 0;
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: fcall_array_unknown (test_member_array_cthread.cpp:285:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next;
logic yarr_a[2][3];
logic yarr_a_next[2][3];
logic [3:0] yarr_b[2][3];
logic [3:0] yarr_b_next[2][3];
logic [3:0] par_b0[3];
logic [3:0] par_b_next0[3];

// Next-state combinational logic
always_comb begin : fcall_array_unknown_comb     // test_member_array_cthread.cpp:285:5
    fcall_array_unknown_func;
end
function void fcall_array_unknown_func;
    logic par_a[3];
    logic [3:0] l;
    j_next = j0;
    par_b_next0 = par_b0;
    yarr_a_next = yarr_a;
    yarr_b_next = yarr_b;
    par_a = yarr_a_next[j_next]; par_b_next0 = yarr_b_next[j_next];
    // Call rec_param0() begin
    l = par_b_next0[0];
    // Call rec_param0() end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : fcall_array_unknown_ff
    if ( rst ) begin
        j0 <= sig;
        yarr_a[j0][0] <= 0;
    end
    else begin
        j0 <= j_next;
        yarr_a <= yarr_a_next;
        yarr_b <= yarr_b_next;
        par_b0 <= par_b_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: simple_access (test_member_array_cthread.cpp:306:5) 

// Thread-local variables
logic s_a[3];
logic s_a_next[3];
logic [3:0] s_b[3];

// Next-state combinational logic
always_comb begin : simple_access_comb     // test_member_array_cthread.cpp:306:5
    simple_access_func;
end
function void simple_access_func;
    integer j;
    logic TMP_0;
    integer i_2;
    s_a_next = s_a;
    j = sig;
    i_2 = j + 1;
    // Call getA() begin
    TMP_0 = s_a_next[i_2];
    // Call getA() end
    s_b[j] = TMP_0 ? j : 0;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : simple_access_ff
    if ( rst ) begin
        logic par;
        integer i_1;
        logic [3:0] s_b[3];
        for (integer i = 0; i < 3; ++i)
        begin
            par = 0; i_1 = i;
            // Call setA() begin
            s_a[i_1] <= par;
            // Call setA() end
            s_b[i] = 0;
        end
    end
    else begin
        s_a <= s_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: array_access (test_member_array_cthread.cpp:328:5) 

// Thread-local variables
logic [3:0] arr_b[2][3];
logic [3:0] arr_b_next[2][3];
logic arr_a[2][3];
logic arr_a_next[2][3];

// Next-state combinational logic
always_comb begin : array_access_comb     // test_member_array_cthread.cpp:328:5
    array_access_func;
end
function void array_access_func;
    integer j_1;
    logic [3:0] l;
    logic TMP_0;
    integer i_2;
    arr_a_next = arr_a;
    arr_b_next = arr_b;
    j_1 = sig;
    l = arr_b_next[j_1][j_1 + 1];
    i_2 = j_1 + 1;
    // Call getA() begin
    TMP_0 = arr_a_next[j_1][i_2];
    // Call getA() end
    arr_b_next[j_1][j_1 + 1] = TMP_0 ? j_1 : 0;
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : array_access_ff
    if ( rst ) begin
        logic par;
        integer i_1;
        for (integer j = 0; j < 2; ++j)
        begin
            for (integer i = 0; i < 3; ++i)
            begin
                par = 0; i_1 = i;
                // Call setA() begin
                arr_a[j][i_1] <= par;
                // Call setA() end
                arr_b[j][i] <= 0;
            end
        end
    end
    else begin
        arr_b <= arr_b_next;
        arr_a <= arr_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: loc_array_access (test_member_array_cthread.cpp:352:5) 

// Thread-local variables
logic [3:0] xarr_b0[2][3];
logic [3:0] xarr_b_next[2][3];
logic [3:0] x_b0[3];
logic [3:0] x_b_next[3];

// Next-state combinational logic
always_comb begin : loc_array_access_comb     // test_member_array_cthread.cpp:352:5
    loc_array_access_func;
end
function void loc_array_access_func;
    logic xarr_a[2][3];
    integer j_1;
    logic [63:0] l;
    logic xarr_par;
    integer xarr_i;
    x_b_next = x_b0;
    xarr_b_next = xarr_b0;
    j_1 = sig;
    l = x_b_next[j_1] + xarr_b_next[j_1 + 1][j_1 + 2];
    x_b_next[j_1] = 1;
    xarr_b_next[j_1 + 1][j_1 + 2] = 2;
    xarr_par = 0; xarr_i = 1;
    // Call setA() begin
    xarr_a[j_1][xarr_i] = xarr_par;
    // Call setA() end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : loc_array_access_ff
    if ( rst ) begin
        logic x_a[3];
        x_b0[0] <= 0; x_b0[1] <= 0; x_b0[2] <= 0;
        for (integer i = 0; i < 3; ++i)
        begin
            x_b0[i] <= i;
        end
        for (integer j = 0; j < 2; ++j)
        begin
            for (integer k = 0; k < 3; ++k)
            begin
                xarr_b0[j][k] <= 0;
            end
        end
    end
    else begin
        xarr_b0 <= xarr_b_next;
        x_b0 <= x_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: local_fcall_param (test_member_array_cthread.cpp:405:5) 

// Thread-local variables
logic vv_a[3];
logic vv_a_next[3];
logic v_a[3];
logic v_a_next[3];
logic signed [31:0] j1;
logic signed [31:0] j_next0;
logic varr_a[2][3];
logic varr_a_next[2][3];
logic [3:0] varr_b[2][3];
logic [3:0] varr_b_next[2][3];
logic [3:0] par_b1[3];
logic [3:0] par_b_next1[3];
logic par_a0[3];
logic par_a_next[3];

// Next-state combinational logic
always_comb begin : local_fcall_param_comb     // test_member_array_cthread.cpp:405:5
    local_fcall_param_func;
end
function void local_fcall_param_func;
    logic [3:0] vv_b[3];
    logic [3:0] v_b[3];
    integer k;
    integer i;
    logic TMP_1;
    integer v_i;
    logic par_a[3];
    logic [3:0] l;
    logic [3:0] par_b_1[3];
    integer j;
    logic TMP_2;
    integer par_i;
    j_next0 = j1;
    par_a_next = par_a0;
    par_b_next1 = par_b1;
    v_a_next = v_a;
    varr_a_next = varr_a;
    varr_b_next = varr_b;
    vv_a_next = vv_a;
    i = 1;
    // Call rec_param1() begin
    vv_b[i] = vv_a_next[i] ? 1 : 2;
    // Call rec_param1() end
    k = 1;
    // Call rec_param2_ref() begin
    v_i = k;    // Call of getA()
    // Call getA() begin
    TMP_1 = v_a_next[v_i];
    // Call getA() end
    v_b[k] = TMP_1 ? 1 : 2;
    // Call rec_param2_ref() end
    par_a = varr_a_next[j_next0]; par_b_next1 = varr_b_next[j_next0];
    // Call rec_param0() begin
    l = par_b_next1[0];
    // Call rec_param0() end
    par_a_next = varr_a_next[j_next0]; par_b_1 = varr_b_next[j_next0]; j = 0;
    // Call rec_param2_val() begin
    par_i = j;
    // Call getA() begin
    TMP_2 = par_a_next[par_i];
    // Call getA() end
    par_b_1[j] = TMP_2 ? 1 : 2;
    // Call rec_param2_val() end
    k = 1;
    // Call rec_param2_ref() begin
    varr_b_next[j_next0][k] = 2;
    // Call rec_param2_ref() end
endfunction

// Synchronous register update
always_ff @(posedge clk or posedge rst) 
begin : local_fcall_param_ff
    if ( rst ) begin
        logic [3:0] v_b[3];
        integer k;
        v_b[0] = 0; v_b[1] = 0; v_b[2] = 0;
        for (integer d = 0; d < 2; ++d)
        begin
            for (integer e = 0; e < 3; ++e)
            begin
                varr_a[d][e] <= 0;
            end
        end
        j1 <= sig;
        k = 0;
        // Call rec_param2_ref() begin
        varr_b[j1][k] <= 2;
        // Call rec_param2_ref() end
    end
    else begin
        vv_a <= vv_a_next;
        v_a <= v_a_next;
        j1 <= j_next0;
        varr_a <= varr_a_next;
        varr_b <= varr_b_next;
        par_b1 <= par_b_next1;
        par_a0 <= par_a_next;
    end
end

//------------------------------------------------------------------------------
// Method process: local_fcall_param_noinit (test_member_array_cthread.cpp:432:5) 

always_comb 
begin : local_fcall_param_noinit     // test_member_array_cthread.cpp:432:5
    logic varr_a_1[2][3];
    logic [3:0] varr_b_1[2][3];
    integer j;
    integer k;
    logic TMP_0;
    integer varr_i;
    j = sig;
    k = 0;
    // Call rec_param2_ref() begin
    varr_i = k;
    // Call getA() begin
    TMP_0 = varr_a_1[j][varr_i];
    // Call getA() end
    varr_b_1[j][k] = TMP_0 ? 1 : 2;
    // Call rec_param2_ref() end
end

endmodule



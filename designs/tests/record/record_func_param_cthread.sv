//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.54
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: A ()
//
module A // "a"
(
    input logic clk
);

// Variables generated for SystemC signals
logic rstn;

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_ref (test_func_param_cthread.cpp:83:5) 

// Thread-local variables
logic s_a;
logic s_a_next;
logic record_fcall_ref_PROC_STATE;
logic record_fcall_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_ref_comb     // test_func_param_cthread.cpp:83:5
    record_fcall_ref_func;
end
function void record_fcall_ref_func;
    integer s_b;
    logic b;
    logic b_1;
    s_a_next = s_a;
    record_fcall_ref_PROC_STATE_next = record_fcall_ref_PROC_STATE;
    
    case (record_fcall_ref_PROC_STATE)
        0: begin
            s_b = 1;
            // Call f1() begin
            b = s_a_next;
            s_b = 2;
            // Call f1() end
            record_fcall_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:91:13;
        end
        1: begin
            // Call f1_const() begin
            b_1 = !s_a_next;
            // Call f1_const() end
            s_b = 1;
            // Call f1() begin
            b = s_a_next;
            s_b = 2;
            // Call f1() end
            record_fcall_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:91:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_ref_ff
    if ( ~rstn ) begin
        integer s_b;
        record_fcall_ref_PROC_STATE <= 0;    // test_func_param_cthread.cpp:86:9;
    end
    else begin
        s_a <= s_a_next;
        record_fcall_ref_PROC_STATE <= record_fcall_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_val_reg (test_func_param_cthread.cpp:98:5) 

// Thread-local variables
logic s_a0;
logic s_a_next0;
logic signed [31:0] s_b0;
logic signed [31:0] s_b_next;

// Next-state combinational logic
always_comb begin : record_fcall_val_reg_comb     // test_func_param_cthread.cpp:98:5
    record_fcall_val_reg_func;
end
function void record_fcall_val_reg_func;
    logic par_a;
    integer par_b;
    logic b;
    s_a_next0 = s_a0;
    s_b_next = s_b0;
    par_a = s_a_next0; par_b = s_b_next;
    // Call f2() begin
    b = par_a;
    par_b = 2;
    // Call f2() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_val_reg_ff
    if ( ~rstn ) begin
        s_b0 <= 1;
    end
    else begin
        s_a0 <= s_a_next0;
        s_b0 <= s_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_val_comb (test_func_param_cthread.cpp:111:5) 

// Next-state combinational logic
always_comb begin : record_fcall_val_comb_comb     // test_func_param_cthread.cpp:111:5
    record_fcall_val_comb_func;
end
function void record_fcall_val_comb_func;
    logic s_a_1;
    integer s_b;
    logic par_a;
    integer par_b;
    logic b;
    s_b = 1;
    par_a = s_a_1; par_b = s_b;
    // Call f2() begin
    b = par_a;
    par_b = 2;
    // Call f2() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_val_comb_ff
    if ( ~rstn ) begin
    end
    else begin
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_val (test_func_param_cthread.cpp:123:5) 

// Thread-local variables
logic s_a1;
logic s_a_next1;
logic signed [31:0] s_b1;
logic signed [31:0] s_b_next0;

// Next-state combinational logic
always_comb begin : record_fcall_two_val_comb     // test_func_param_cthread.cpp:123:5
    record_fcall_two_val_func;
end
function void record_fcall_two_val_func;
    logic r_a;
    integer r_b;
    logic par1_a;
    integer par1_b;
    logic par2_a;
    integer par2_b;
    logic b;
    s_a_next1 = s_a1;
    s_b_next0 = s_b1;
    par1_a = s_a_next1; par1_b = s_b_next0; par2_a = r_a; par2_b = r_b;
    // Call f3() begin
    b = par1_a || par2_a;
    par1_a = |(b + 1);
    par2_a = |(b - 1);
    // Call f3() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_val_ff
    if ( ~rstn ) begin
    end
    else begin
        s_a1 <= s_a_next1;
        s_b1 <= s_b_next0;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_val2 (test_func_param_cthread.cpp:136:5) 

// Thread-local variables
logic signed [31:0] gr_b;
logic signed [31:0] gr_b_next;
logic gr_a;

// Next-state combinational logic
always_comb begin : record_fcall_two_val2_comb     // test_func_param_cthread.cpp:136:5
    record_fcall_two_val2_func;
end
function void record_fcall_two_val2_func;
    logic s_a_1;
    integer s_b;
    logic par1_a;
    integer par1_b;
    logic par2_a;
    integer par2_b;
    logic b;
    gr_b_next = gr_b;
    gr_a = 1;
    par1_a = gr_a; par1_b = gr_b_next; par2_a = s_a_1; par2_b = s_b;
    // Call f3() begin
    b = 1;
    par1_a = |(b + 1);
    par2_a = |(b - 1);
    // Call f3() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_val2_ff
    if ( ~rstn ) begin
    end
    else begin
        gr_b <= gr_b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_ref (test_func_param_cthread.cpp:148:5) 

// Thread-local variables
logic s_a2;
logic s_a_next2;
logic record_fcall_two_ref_PROC_STATE;
logic record_fcall_two_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_two_ref_comb     // test_func_param_cthread.cpp:148:5
    record_fcall_two_ref_func;
end
function void record_fcall_two_ref_func;
    integer s_b;
    logic r_a;
    integer r_b;
    logic b;
    s_a_next2 = s_a2;
    record_fcall_two_ref_PROC_STATE_next = record_fcall_two_ref_PROC_STATE;
    
    case (record_fcall_two_ref_PROC_STATE)
        0: begin
            record_fcall_two_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:153:13;
        end
        1: begin
            // Call f4() begin
            b = s_a_next2 && r_a;
            s_a_next2 = b;
            // Call f4() end
            record_fcall_two_ref_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:153:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_ref_ff
    if ( ~rstn ) begin
        record_fcall_two_ref_PROC_STATE <= 0;    // test_func_param_cthread.cpp:150:9;
    end
    else begin
        s_a2 <= s_a_next2;
        record_fcall_two_ref_PROC_STATE <= record_fcall_two_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_two_ref2 (test_func_param_cthread.cpp:161:5) 

// Thread-local variables
logic gs_a;
logic gs_a_next;
logic r_a0;
logic r_a_next;

// Next-state combinational logic
always_comb begin : record_fcall_two_ref2_comb     // test_func_param_cthread.cpp:161:5
    record_fcall_two_ref2_func;
end
function void record_fcall_two_ref2_func;
    integer r_b;
    logic b;
    gs_a_next = gs_a;
    r_a_next = r_a0;
    r_b = 4;
    // Call f4() begin
    b = gs_a_next && r_a_next;
    gs_a_next = b;
    // Call f4() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_two_ref2_ff
    if ( ~rstn ) begin
        integer r_b;
    end
    else begin
        gs_a <= gs_a_next;
        r_a0 <= r_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref1 (test_func_param_cthread.cpp:179:5) 

// Thread-local variables
logic t_a;
logic t_a_next;
logic signed [31:0] t_b;
logic signed [31:0] t_b_next;
logic r_a1;
logic r_a_next0;
logic signed [31:0] r_b0;
logic signed [31:0] r_b_next;
logic record_fcall_const_ref1_PROC_STATE;
logic record_fcall_const_ref1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref1_comb     // test_func_param_cthread.cpp:179:5
    record_fcall_const_ref1_func;
end
function void record_fcall_const_ref1_func;
    logic TMP_0;
    logic b;
    r_a_next0 = r_a1;
    r_b_next = r_b0;
    t_a_next = t_a;
    t_b_next = t_b;
    record_fcall_const_ref1_PROC_STATE_next = record_fcall_const_ref1_PROC_STATE;
    
    case (record_fcall_const_ref1_PROC_STATE)
        0: begin
            // Call cref_copy() begin
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            // Call cref_copy() end
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            record_fcall_const_ref1_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:186:13;
        end
        1: begin
            // Call cref_cmp() begin
            TMP_0 = r_a_next0 == t_a_next && r_b_next == t_b_next;
            // Call cref_cmp() end
            b = TMP_0;
            // Call cref_copy() begin
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            // Call cref_copy() end
            r_a_next0 = t_a_next; r_b_next = t_b_next;
            record_fcall_const_ref1_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:186:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref1_ff
    if ( ~rstn ) begin
        record_fcall_const_ref1_PROC_STATE <= 0;    // test_func_param_cthread.cpp:182:9;
    end
    else begin
        t_a <= t_a_next;
        t_b <= t_b_next;
        r_a1 <= r_a_next0;
        r_b0 <= r_b_next;
        record_fcall_const_ref1_PROC_STATE <= record_fcall_const_ref1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref2 (test_func_param_cthread.cpp:196:5) 

// Thread-local variables
logic r_a2;
logic r_a_next1;
logic t_a0;
logic t_a_next0;
logic signed [31:0] t_b0;
logic signed [31:0] t_b_next0;
logic signed [31:0] r_b1;
logic signed [31:0] r_b_next0;
logic record_fcall_const_ref2_PROC_STATE;
logic record_fcall_const_ref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref2_comb     // test_func_param_cthread.cpp:196:5
    record_fcall_const_ref2_func;
end
function void record_fcall_const_ref2_func;
    logic TMP_0;
    logic b;
    r_a_next1 = r_a2;
    r_b_next0 = r_b1;
    t_a_next0 = t_a0;
    t_b_next0 = t_b0;
    record_fcall_const_ref2_PROC_STATE_next = record_fcall_const_ref2_PROC_STATE;
    
    case (record_fcall_const_ref2_PROC_STATE)
        0: begin
            t_a_next0 = 1;
            record_fcall_const_ref2_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:202:13;
        end
        1: begin
            // Call cref_cmp() begin
            TMP_0 = r_a_next1 == t_a_next0 && r_b_next0 == t_b_next0;
            // Call cref_cmp() end
            b = TMP_0;
            t_a_next0 = 1;
            record_fcall_const_ref2_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:202:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref2_ff
    if ( ~rstn ) begin
        record_fcall_const_ref2_PROC_STATE <= 0;    // test_func_param_cthread.cpp:199:9;
    end
    else begin
        r_a2 <= r_a_next1;
        t_a0 <= t_a_next0;
        t_b0 <= t_b_next0;
        r_b1 <= r_b_next0;
        record_fcall_const_ref2_PROC_STATE <= record_fcall_const_ref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: record_fcall_const_ref3 (test_func_param_cthread.cpp:213:5) 

// Thread-local variables
logic r_a3;
logic r_a_next2;
logic signed [31:0] r_b2;
logic signed [31:0] r_b_next1;
logic t_a1;
logic t_a_next1;
logic signed [31:0] t_b1;
logic signed [31:0] t_b_next1;
logic [1:0] record_fcall_const_ref3_PROC_STATE;
logic [1:0] record_fcall_const_ref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : record_fcall_const_ref3_comb     // test_func_param_cthread.cpp:213:5
    record_fcall_const_ref3_func;
end
function void record_fcall_const_ref3_func;
    integer TMP_0;
    integer res;
    integer i;
    integer TMP_2;
    integer TMP_3;
    r_a_next2 = r_a3;
    r_b_next1 = r_b2;
    t_a_next1 = t_a1;
    t_b_next1 = t_b1;
    record_fcall_const_ref3_PROC_STATE_next = record_fcall_const_ref3_PROC_STATE;
    
    case (record_fcall_const_ref3_PROC_STATE)
        0: begin
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:208:9;
            // Call cref_sum() end
        end
        1: begin
            // Call cref_sum() begin
            res = t_a_next1 + t_b_next1;
            TMP_0 = res;
            // Call cref_sum() end
            i = TMP_0;
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 2; return;    // test_func_param_cthread.cpp:208:9;
            // Call cref_sum() end
        end
        2: begin
            // Call cref_sum() begin
            res = r_a_next2 + r_b_next1;
            TMP_2 = res;
            // Call cref_sum() end
            i = TMP_2;
            // Call cref_sum() begin
            record_fcall_const_ref3_PROC_STATE_next = 1; return;    // test_func_param_cthread.cpp:208:9;
            // Call cref_sum() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge rstn) 
begin : record_fcall_const_ref3_ff
    if ( ~rstn ) begin
        record_fcall_const_ref3_PROC_STATE <= 0;    // test_func_param_cthread.cpp:216:9;
    end
    else begin
        r_a3 <= r_a_next2;
        r_b2 <= r_b_next1;
        t_a1 <= t_a_next1;
        t_b1 <= t_b_next1;
        record_fcall_const_ref3_PROC_STATE <= record_fcall_const_ref3_PROC_STATE_next;
    end
end

endmodule


